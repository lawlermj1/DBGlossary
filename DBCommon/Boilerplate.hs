{-# LANGUAGE DeriveDataTypeable #-} 
{-# LANGUAGE RankNTypes #-} 
{-# LANGUAGE ExistentialQuantification #-} 
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE ViewPatterns #-}
{-# LANGUAGE DeriveFunctor, DeriveFoldable, DeriveTraversable #-} 

{- |
   Module      : DBCommon.Boilerplate
   Description : Scrap Your Boilerplate functions
   Copyright   : ( c ) Matthew Lawler 2018 
   License     : 2-Clause BSD
   Maintainer  : lawlermj1@gmail.com
   
   This module defines generic functions that traverse data types. 
   These functions enable show, default values, load, unload and type checking. 
   In addition, there are property functions to test if the generated boilerplate functions work correctly for each type. 

   Properties that should hold for each type: 

    The Equivalent Function Property. 
    That is, for all types, the equivalent functions should produce equal results.  
    The functions needs to process the immediate subterms of an algebraic data type and perform some transformation. 
    The two approaches used were, firstly, gmapQ from Data.Data and secondly, gunfold defined by Oleg Kiselyov at http://okmij.org/ftp/Haskell/generics.html 
    Oleg Kiselyov's blog discusses Data-Generic and Data-Extensible Programming in Haskell. 
    The used properties are: 
        prop_gADTD2Tree_eq_gADTU2Tree - DTTree or Data Type Tree of the algebraic data type is the same using gmapQ or gunfold. 
        prop_gADTD2List_eq_gADTU2List - Data Type List of the algebraic data type is the same using gmapQ or gunfold. 
        prop_gldD_eq_gldU - The load function generated by gmapQ or gunfold produces the same results. 
        prop_guldD_eq_guldU - The unload function generated by gmapQ or gunfold produces the same results. 
    These properties need to be True for all declared data types. 
    
    Other possible properties include: 
        gdefault == gd 
        gelemsD == geU 
        gcheckEnumTypeD == gcheckEnumTypeU  
        gcheck == gcheckUnfold         
        gcount == gcountFieldsUnfold 
        count gheader == count gcount 

   The Inverse Function Property. 
   That is, for all types, composing the function and its inverse should equal the identity function.  
    The used properties are: 
        prop_inverse_gread - ( fst.head.gread.gshow ) a == id a or read and show are inverses 
        
    Other possible properties include: 
        gload.gunload = id 

     Note: The full gunfold is not used. Specifically, recursive data types are not handled. 
        
 -}
module DBCommon.Boilerplate
    (  
--    MAIN FUNCTIONS   
--    used in almost all modules to eliminate boilerplate 
--    generic show e.g. instance Show ColumnIn where show = gshowQ      
      gshowQ, 
--    generic default function e.g. columnInDefault = gdefaultU ( undefined::ColumnIn )  
      gdefaultU, 
      gdefaultD,  
--    generic load function e.g.columnInLoad = gloadU ( undefined::ColumnIn ) 
      gloadU, 
--    generic header function used in a few IO functions 
      gheaderShowQ, 
--    generic checking used to determine if string satisfies type rules 
      gcheckU, 

--    HELPERS  
--    splits string on tabs 
      wordsTab, 
      sepCharS, 
      string2DayDefault,      

--    INVARIANTS         
--  Some invariant properties 
--    These are possible because most types can be generated by 2 approaches. 
--    g*D generic functions use SPJ's Data.Data dataTypeOf approach 
--    g*D means the function must have a Defined type as input 
--    g*U generic functions use Oleg's TRepTree approach  
--    g*U means the function takes an Undefined type as input 
--    This means that the results can be compared, and they should be identical. 
      prop_gADTD2List_eq_gADTU2List, 
      prop_gADTD2Tree_eq_gADTU2Tree, 
      
      prop_gelems_eq_gelemsU, 
      prop_gcount_eq_gcountU, 
      prop_gheader_length_eq_gcountU, 
      prop_gheaderShowQ_eq_gheaderShowD,       
      prop_inverse_gread, 
      prop_gcheckD_eq_gcheckU, 
      prop_gcheck1D_eq_gcheck1U,

      prop_gldD_eq_gldU,
      prop_guldD_eq_guldU,

      prop_gcheckEnumType_eq_gcheckEnumTypeU, 
      
-- !!! NOTE: these functions are exposed only for internal testing. 
      showDT,
      gADTU2ListU, 
      gADTD2ListD, 
--    There is NO need to use them. 
--    generic checking used to determine if string satisfies type rules 
--      gcheckD, 
--      gcheck1U,
--      gcheck1D,
--    generic reads ( needed for generic checking and testing )
--      greadF, 
--      greadEither, 
--      greadMaybe,
--    returns all sum types as a list of strings 
--      gelemsD, 
--    checks if a string is an elem of a sum type ( converted to strings ) 
--      gcheckEnumTypeD, 
--    counting accessors for testing 
      gcountFieldD,
      gcountShowD,
--    generic load function 
      gloadD,
--  generic header function useful for CSV export 
      gheaderShowD, 
      gheaderFieldD, 
--    generic function to convert a type to a string 
      gunloadD,  
--    returns all sum types as a list of strings       
      gelemsU, 
--    checks if a string is an elem of a sum type ( converted to strings ) 
      gcheckEnumTypeU,
--    counting accessors for testing       
      gcountFieldU, 
      gcountShowU,
--    converts an undefined type into a default string 
      gdS,
      gdSL, 
      gdQ,
--    converts an undefined type into a NamedA list    
      guldU, 

     ) where

import Data.Char 
import Data.Generics 
import Data.List  
import qualified Data.Map.Strict as M  
import Data.Maybe  
import Data.Time 

--  import Data.List.Split  
import Control.Applicative 
import Control.Applicative.Combinators as C 

--    import Oleg.GMap 
--    import Oleg.TypeReflFull 

import DBCommon.PreludeGapFiller  
import DBCommon.EnumType  

-------------------------------------
--    copied from Oleg from TypeReflFull.hs 
-- In this general problem, we are not given any value of the type
-- to reify. For an algebraic data type, we have to find out 
-- all its variants, that is, all its constructors, and their
-- arguments. Finding out the arguments of a data constructor
-- is a challenge: Data.Data offers no built-in facility for that
-- purpose.

-- First, we convert a type to a tree that describes it
-- Actually, it is a graph because the type can be recursive.

data TRepTree = TData TRep [TCon] | BackRef TypeRep
                deriving Show

-- ( shallow ) description of a data type
data TRep = forall a. Data a => TRep a

instance Show TRep where
--    show ( TRep x ) = show . dataTypeName . dataTypeOf $ x
    show ( TRep x ) = show . typeOf $ x

-- A description of a data constructor, with all its arguments.
-- We stress that Data.Data.Constr tells only the name ( and the index )
-- of a data constructor -- but not its arguments.
data TCon = TCon Constr [TRepTree]      -- a data constructor and its args
          deriving Show
                   
-- gunfold needs the type constructor defining the context of
-- unfolding. We use two such constructors below: CCList for
-- determining the arguments of a constructor and CTTree for
-- determining the graph of a data type
newtype CTTree a = CTTree TRepTree    deriving Show
newtype CCList a = CCList [TRepTree]  deriving Show

-- To detect loops, we keep track of the types we have already seen
type SeenTypes = [TypeRep] 

-- The user may wish to treat certain types as primitives and
-- avoid traversing them
type IgnoreTypes = [TypeRep]

--    called by describe_type'  
describe_ctor :: Data a => IgnoreTypes -> SeenTypes -> Constr -> CCList a
describe_ctor ignore seen = gunfold branch empty
 where
 branch :: forall r b. Data b => CCList ( b -> r ) -> CCList r
 branch ( CCList n ) = let CTTree n1 = describe_type' ignore seen :: CTTree b
                     in CCList ( n1:n )
 empty  :: r -> CCList r
 empty _ = CCList []             -- Leaf of the type tree

--    called by describe_type 
describe_type' :: forall a. Data a => IgnoreTypes -> SeenTypes -> CTTree a
describe_type' ignore seen = check seen ( typeOf ( undefined::a ) )
 where
 check seen trep | trep `elem` ignore = CTTree ( TData ( TRep ( undefined::a ) ) [] )
 check seen trep | trep `elem` seen = CTTree ( BackRef trep )
 check seen trep =
     CTTree ( TData ( TRep ( undefined::a ) ) $
              map ( make_tcon ( trep:seen ) ) ( ctors ( undefined :: a ) ) )
 ctors :: forall a. Data a => a -> [Constr]  -- all constructors of a data type
 ctors x = let dt = dataTypeOf x 
--  ML         in case dataTypeRep dt of
--  ML                 ( AlgRep ctrs ) -> ctrs 
--  ML                 _            -> [] 
            in case dataTypeRep dt of { ( AlgRep ctrs ) -> ctrs ; _ -> [] } 
                    
 make_tcon seen ctor =
    let CCList lst = describe_ctor ignore seen ctor :: CCList a in
    TCon ctor ( reverse lst )

--    main entry point 
describe_type :: forall a. Data a => IgnoreTypes -> a -> TRepTree
describe_type ignore _ = tree
 where
 CTTree tree = describe_type' ignore [] :: CTTree a
 
castfn :: ( Typeable a, Typeable b, Typeable c, Typeable d ) =>
          ( a -> b ) -> Maybe ( c -> d )
castfn f = cast f 

-- ----------------------------------------------------- 
--    TRep helpers

--    is this a base or primitive TRep?  
--    if no, then it is an Algebraic Data Type 
--    how to determine if is an Enum or non-enum type? 
isTRepBaseType :: TRep -> Bool  
isTRepBaseType t 
    | elem st ["[Char]","Char","Int","Integer","Float","Bool","Double"] = True    
    | otherwise = False  
    where st = show t 
    
--    checks if this TRep is a monad 
isTRepMonad :: TRep -> Bool  
isTRepMonad t 
--    empty string is false; makes following head safe 
    | st == [] = False 
--    put in named Monads here
    | take 5 st == "Maybe" = True 
--    matching with string will be treated as a base type 
    | st == "[Char]" = False 
--    these are safe calls to head and last 
--    match head and last for a List monad 
    | ( head st ) == '[' && ( last st ) == ']' = True 
    | otherwise = False  
    where st = trim(  show t  ) 
    
--    not sure how to do this 
isTRepEnumType :: TRep -> Bool  
isTRepEnumType t = undefined 
    
--    checks if this TRep is a product or sum Constructor  
--    assume that if it is not Base, Monad, it must be Product/Sum   
isTRepProdSum :: TRep -> Bool  
isTRepProdSum t 
    | isTRepBaseType t = False 
    | isTRepMonad t = False 
    | otherwise = True  

--    if a TCon has no TRepTree sublist, then it has no parms indicating an EnumType 
isTConEnumType :: TCon -> Bool 
isTConEnumType ( TCon _ tReps )  
    | length tReps == 0 = True 
    | otherwise = False 
    
--    is this a constructor for a Monad? 
--    add additional monad constructors, as they are used 
isTConMonad :: TCon -> Bool 
isTConMonad ( TCon ctor _ )  
    | elem st ["[]","(:)","Nothing","Just"] = True    
    | otherwise = False  
    where st = show ctor  
    
--    extracts name of data type     
gname :: Data a => a -> String 
gname a 
    = trim(  show tRep ) 
    where dt@( TData tRep _ ) = describe_type [] a 

-- ----------------------------------------------------- 
-- Real generic map from GMap.hs 
--
-- Two insights: the type changing mapping function can be accommodated
-- via a serialize-transform-deserialize trick. The serialized
-- value, after the transformation, can be read back at a different
-- type. 
-- For more detail, see
-- http://okmij.org/ftp/Haskell/generics.html#gmap

gmap :: forall a b c .
        ( Data a, Data b, Data ( c a ), Data ( c b ), Data ( c X ) ) => 
        ( a -> b ) -> c a -> c b
gmap f = gmapt f ( Dyn ( undefined::c X ) )


-- This code uses the following spot-mark X defined in Claus' code

-- "X marks the spots";- ) X should be private
data X = X deriving ( Data,Typeable )

{-
Alexey: ``You are passing around an explicit type representation at
run-time, to ensure that the transforming function applies only to
X-positions.''

gmapt gets the value x to traverse and the template. The template is a
Dyn whose type has the same basic structure as that of x. The following
equation is supposed to hold:
  tt{X:=a} = typeOf x where ( Dyn t ) = template; tt = typeOf t
where {X:=a} is a substitution that replaces all occurrences of a singleton
type X with some other suitable type a.
For example, 
   x has the type        [Int]
   template has the type [X]

   x has the type        ( Int, Int )
   template has the type ( X, Int )

   x has the type        ( Int, Int )
   template has the type ( X, X )

Although 'x' is the defined value, template is generally an undefined
value.  The trick is to build the template `out of nothing', in a
shallow way, to the extent to enable further traversal. The trick is
the observation that x and template should share the same data
structure, or at least the same top-level data constructor.

The following includes an optimization: if typeof template == typeof x,
there is nothing to traverse. Only values that correspond to the mark X
in the template are mapped.

The 'error' functions below do consistency checks. If gmapt is invoked
only through gmap as shown above, none of these checks shall fail.
-}


gmapt :: ( Data a, Data b, Data x, Data y ) => ( a -> b ) -> Dyn -> x -> y
gmapt f trep = maybe ( \x -> traverse ( trep,x ) ) ifmarked $ castfn f
 where
  hasmark :: Dyn -> Bool
  hasmark ( Dyn x ) = typeOf x == typeOf X

  -- The gmapped value x has the right type to be transformed by 'f'
  -- We do the transformation only if 'x' has the mark
  -- ifmarked :: Typeable x => ( x->y ) -> ( x->y )
  ifmarked f x | hasmark trep = f x
  ifmarked f x = traverse ( trep,x )
  
  -- optimization: t has no mark, there is nothing to map under it
  traverse ( Dyn t,x ) | typeOf t == typeOf x = 
              maybe ( error "traverse1" ) id $ cast x
  traverse ( Dyn t,x ) | ( tcon,tkids ) <- splitTyConApp ( typeOf t ),
                       ( con,kids )   <- splitTyConApp ( typeOf x ),
                       not ( length tkids == length kids && tcon == con ) =
     error $ unwords ["template type", show ( typeOf t ),
                      "inconsistent with value type", show ( typeOf x )]
  traverse ( Dyn t,x ) = rebuild f ( serialize t1 ) xdyn
    where xdyn@( con,kids ) = serialize x
          t1 = fromConstr con `asTypeOf` t  -- build the ephemeral template

-- The serialization step

-- The serialized value: the data constructor descriptor and the list 
-- of its arguments, lazily serialized ( that is, wrapped in Dyn )
type Serialized = ( Constr,[Dyn] )
data Dyn = forall a. Data a => Dyn a

data Kids a = Kids{growUp:: [Dyn]}
serialize :: Data a => a -> Serialized
serialize x = ( toConstr x, growUp $ gfoldl k ( const ( Kids [] ) ) x )
  where k ( Kids l ) a = Kids ( l ++ [Dyn a] )

tdyn1 = serialize "abcd"

-- The deserialization step ( which traverses the template in parallel )
-- It reassembles the value from the possibly transformed subcomponents
data UnfldStateT a = UnfldStateT a [Dyn] [Dyn]

rebuild :: ( Data a, Data b, Data t ) =>
           ( a->b ) -> Serialized -> Serialized -> t
rebuild f ( tcon, tkids ) ( con, kids ) = 
       case gunfold k ( \g -> UnfldStateT g tkids kids ) con of
         UnfldStateT a [] [] -> a
  where k ( UnfldStateT ca ( tkid:tkids ) ( ( Dyn kid ):kids ) ) = 
            UnfldStateT ( ca ( gmapt f tkid kid ) ) tkids kids

toChar i = chr ( i + ord 'A' )

-------------------------------------
--    types for kindy things 

data DTType = EnumDT | BaseDT | ProductDT | CloseBracketDT | MonadDT | CloseListBracketDT deriving (  Eq, Ord, Typeable, Show, Read  ) 

data DT = DT { 
      dTName :: String 
    , dTType :: DTType
    , dTConfields :: [String] 
--    +1 if a field ( enum or base, 0 if Product or Bracket  
    , dTFieldIndex :: Int 
--    +1 if shown ( enum, base or product ), 0 if Bracket 
    , dTShowIndex :: Int 
--    name of accessor function 
    , dTAccessor :: Maybe String 
--    is this field inside a Monad such as [] or Maybe?  
    , dTIsInMonad :: Bool 
--    what level in this field inside a Monad?   
    , dTMonadLevel :: Int      
    } deriving (  Typeable, Show, Ord, Read, Eq ) 
    
dTDefault = DT " " BaseDT [] 0 0 Nothing False 0 
dTCloseBracket = dTDefault { dTName = "  ) ", dTType = CloseBracketDT }  
dTCloseListBracket = dTDefault { dTName = " ( [] ) ) ", dTType = CloseListBracketDT }  

--    alternate equality function used in properties 
--    dTConfields and dTAccessor are different for defined and undefined types 
dTEq :: DT -> DT -> Bool 
dTEq dt1 dt2 
    = dTName dt1 == dTName dt2 
    && dTType dt1 == dTType dt2 
    && dTFieldIndex dt1 == dTFieldIndex dt2 
    && dTShowIndex dt1 == dTShowIndex dt2 
    && dTIsInMonad dt1 == dTIsInMonad dt2 
    && dTMonadLevel dt1 == dTMonadLevel dt2   
    
--    custom show to discover differences between DT versions 
showDT :: DT -> String 
showDT dt 
    = intercalate sepCharS [dTName dt, show ( dTType dt ), show ( dTFieldIndex dt ), show ( dTShowIndex dt ), show ( dTIsInMonad dt ), show ( dTMonadLevel dt )] 

---------------------------------
--    DT 
--    true if the field is a Base or Enum Type, False if it is a Product Type 
gIsFieldDT :: DT -> Bool 
gIsFieldDT dt  
    | elem ( dTType dt ) [BaseDT,EnumDT,MonadDT] = True 
    | otherwise = False  
    
--    Base, Enum or Product Types can be seen when a type is shown 
gIsShowDT :: DT -> Bool 
gIsShowDT dt  
    | elem ( dTType dt ) [BaseDT,EnumDT,ProductDT] = True 
    | otherwise = False  
    
--    true if the field is a Product Type 
gIsProductDT :: DT -> Bool 
gIsProductDT dt = dTType dt == ProductDT 

--    true if the field is a CloseBracket Type 
gIsCloseBracketDT :: DT -> Bool 
gIsCloseBracketDT dt = dTType dt == CloseBracketDT 

--    true if the field is a Bracket Type 
gIsBracketDT :: DT -> Bool 
gIsBracketDT dt = dTType dt == CloseBracketDT || dTType dt == CloseListBracketDT 

--    always true 
gAlwaysDT :: DT -> Bool 
gAlwaysDT _ = True   

--    increments the field index  
--    uses the first DT to carry forward the state or index 
--    if a field ( Base or ENUM ) then increment the Field Index, otherwise make it 0 
--    if shown, ( Base, ENUM or product ) then increment the Show Index, otherwise make it 0 
incTFieldIndex :: DT -> DT -> DT 
incTFieldIndex dt1 dt2 = dt2 { 
      dTFieldIndex = ( dTFieldIndex dt1 ) + ( if gIsFieldDT dt2 then 1 else 0 ) 
    , dTShowIndex = ( dTShowIndex dt1 ) + ( if gIsShowDT dt2 then 1 else 0 ) } 

--    v2 using generic mapSnd 
updatedTFieldIndex2 :: [DT] -> [DT] 
updatedTFieldIndex2 = mapSnd incTFieldIndex 

--    add accessor 
fixAccessor :: String -> DT -> DT 
fixAccessor s dt = dt { dTAccessor = Just s } 
        
--    captures the tree state ( eg monad flag ) 
getMonadState :: ( Bool,Int ) -> DT -> ( Bool,Int ) 
getMonadState ( iim,lvl ) dt 
--    true if already set 
    | iim = ( True, lvl+1 )  
--    switch to True if this is a monad 
    | otherwise = ( dTType dt == MonadDT, 0 ) 
    
--    sets the DT values   
updateDT :: ( Bool,Int ) -> DT -> DT 
updateDT ( iim,lvl ) dt 
    | otherwise = dt { dTIsInMonad = iim, dTMonadLevel = lvl } 
    
--------------------------------
--    DTTree 
--    The DTTree or Data Type Tree is a representation of the algebraic data type 
--    that can be used for subsequent transformation. 
data DTTree a = DTNode { 
        dTRootLabel :: Maybe a,
        dTSubForest :: [DTTree a] } deriving (  Typeable, Show, Ord, Read, Eq, Functor, Foldable ) 
        
--    instance Functor DTTree where 
--    fmap f ( DTNode x ts ) = DTNode ( if isNothing x then Nothing else Just ( f ( fromJust x ) ) ) ( map ( fmap f ) ts )

--instance Show a => Show ( DTTree a ) where 
--    show ( DTNode x ts0 ) 
--        = concat [show ( fromJust x ), sepCharS, concat ( map show ts0 )] 

--    fmap?? 
mapTree :: ( DTTree a -> DTTree a ) -> DTTree a -> DTTree a 
mapTree f ( DTNode t sf ) 
--    | trace ( "mapTree: t = " ++ show t ++ " : sf = " ++ intercalate ":" ( map show sf )  ) False = undefined 
    | otherwise = f ( DTNode t ( map ( mapTree f ) sf ) ) 

--    copies general tree fold 
treeFold :: ( Maybe a -> [t] -> t ) -> DTTree a -> t 
treeFold g = f  
    where f ( DTNode t sf ) = g t ( map f sf ) 
    
--    folds f and b over each element of a tree  
--    defined but not used.. 
treeFold2 :: ( b -> a -> a ) -> b -> DTTree a -> DTTree a 
treeFold2 f b ( DTNode t sf ) 
    | isNothing t = DTNode t sf 
    | otherwise = DTNode ( Just ( f b ( fromJust t ) ) ) ( map ( treeFold2 f b ) sf ) 

--    applies a predicate to each tree in all forests of a DTTree 
filterForest :: ( DTTree a -> Bool ) -> DTTree a -> DTTree a 
filterForest p ( DTNode t sf )  
    = DTNode t ( map ( filterForest p ) ( filter p sf ) )  
    
--    used to filter Nothing DTs 
isNotNothingDTNode :: ( Eq a  ) => DTTree a -> Bool 
isNotNothingDTNode t = not ( t == ( DTNode Nothing [] ) ) 

--    flattens the tree depth first 
flattenDFS :: DTTree a -> [a] 
flattenDFS t = catMaybes ( flattenDFS' [t] )  
    where
        flattenDFS' [] = []
        flattenDFS' ( ( DTNode n sf ) : ts ) = n : flattenDFS' ( sf ++ ts ) 
        
--    traverses over a tree updating state in a node 
--    f captures state changes 
--    g applies the state to a tree node      
--    b holds the state 
--    this traverses quite well. : ) 
treeFix :: ( b -> a -> b ) -> ( b -> a -> a ) -> b -> DTTree a -> DTTree a 
treeFix f g b ( DTNode t sf ) 
    | isNothing t = DTNode t sf 
    | otherwise = DTNode ( Just ( g newb ft ) ) ( map ( treeFix f g newb ) sf ) 
    where 
        ft = fromJust t
        newb = f b ft         

--    pairs up elements of trees 
zipTree :: DTTree a -> DTTree b -> DTTree ( a,b ) 
zipTree ( DTNode t1 sf1 ) ( DTNode t2 sf2 ) 
--    discard the root if any root is a Nothing  
    | isNothing t1 || isNothing t2 = DTNode Nothing []  
--    only make a root pair if both roots exist 
--    zip automatically truncates the longer subforest  
    | otherwise = DTNode ( Just ( fromJust t1, fromJust t2 ) ) ( map ( \( u1,u2 ) -> zipTree u1 u2 ) ( zip sf1 sf2 ) ) 
    
---    get number of level turtles 
height :: DTTree a -> Int 
height = treeFold levelP 

---    adds 1 for each level 
levelP :: Maybe a -> [Int] -> Int 
levelP a ts 
    | isNothing a = 0 + maxOr0 ts 
    | otherwise = 1 + maxOr0 ts     
    
--    copied general root old 
rootFold :: ( Eq a  ) => ( Maybe a -> [t] -> t ) -> DTTree a -> t 
rootFold useNode = f where 
    f ( DTNode t sf ) 
        | sf == [] = useNode t [] 
        | otherwise = useNode t [f ( head sf )] 
        
--    height of the root nodes ??
heightRoot :: ( Eq a  ) => DTTree a -> Int 
heightRoot = rootFold rootP 

---    adds 1 for each level 
rootP :: Maybe a -> [Int] -> Int 
rootP a ts 
    | isNothing a = 0 + maxOr0 ts 
    | otherwise = 1 + maxOr0 ts  
    
--    gets first tree of subforest 
firstRoot :: ( Eq a  ) => DTTree a -> DTTree a  
firstRoot ( DTNode t sf )
    | sf == [] = DTNode t sf 
    | otherwise = head sf 
    
--    find nth root
--    reaches down into the first tree to extract nth root
nthRoot :: ( Eq a, Show a ) => Int -> DTTree a -> Maybe a 
nthRoot n ( DTNode t sf ) 
    | n == 0 = t 
    | heightRoot ( DTNode t sf )  <= n = Nothing 
    | otherwise = rt 
    where rt = dTRootLabel ( ( foldr ( . ) id ( replicate n firstRoot ) ) ( DTNode t sf ) ) 
    
--    find nth tree forest 
--    reaches down into the first trees to extract nth forest 
nthForest :: ( Eq a ) => Int -> DTTree a -> [DTTree a]
nthForest n ( DTNode t sf ) 
    | n == 0 = sf 
    | heightRoot ( DTNode t sf )  <= n = []  
    | otherwise = nf 
    where nf = dTSubForest ( ( foldr ( . ) id ( replicate n firstRoot ) ) ( DTNode t sf ) )     

--    changes tree structure by replacing one branch with another 
--    once a predicate is true, apply the function, and skip all head subforests 
--    and then run it over all subforest 
--    this will enable fixing of monads, which only occur in the head of subforests 
branchReplace :: ( Show a ) => ( DTTree a -> Bool ) -> ( DTTree a -> DTTree a ) -> ( DTTree a -> DTTree a ) 
branchReplace p f ( DTNode t sf ) 
    | isNothing t = ( DTNode t sf )  
    | length sf == 0 = ( DTNode t sf )  
    | p ( DTNode t sf ) = f ( DTNode t sf )  
    | otherwise = DTNode t ( map ( branchReplace p f ) sf )    

--    update Single DTTree root node Only 
updateDTTreeRoot :: ( a -> a ) -> DTTree a -> DTTree a 
updateDTTreeRoot f ( DTNode t sf ) 
--    | trace ( "updateDTTreeRoot: s = " ++ s ++ " : t = " ++ show t ++ " : sf = " ++ intercalate ":" ( map show sf )  ) False = undefined 
    | isNothing t = DTNode t sf 
    | otherwise = DTNode ( Just ( f ( fromJust t ) ) ) sf 
    
--------------------------------
--     DTTree + DT 

dTTreeCloseBracket = DTNode ( Just dTCloseBracket ) [] 
dTTreeCloseListBracket = DTNode ( Just dTCloseListBracket ) [] 
    
--    append a close bracket as last element of the sub-forest sf 
--    only apply id there are constructors 
appendBracketDTTree :: DTTree DT -> DTTree DT 
appendBracketDTTree ( DTNode t sf ) 
--    | trace ( "appendBracketDTTree: t = " ++ show t ++ " : sf = " ++ intercalate ':' ( map show sf )  ) False = undefined 
    | isNothing t = DTNode t sf     
    | sf == [] = DTNode t sf 
--    add close list bracket 
    | ( dTName.fromJust ) t == "(:)" = DTNode t ( sf ++ [dTTreeCloseListBracket] ) 
--    add normal bracket
    | otherwise = DTNode t ( sf ++ [dTTreeCloseBracket] ) 
    
--    collapse a single instance forest with its sub tree 
fixDTnode :: DTTree DT -> DTTree DT 
fixDTnode ( DTNode t sf ) 
--    ignore nothing nodes  
    | isNothing t = DTNode t sf 
--    ignore empty forests 
    | length sf == 0 = DTNode t sf 
--    if there is only tree in the forest, and the name and type are equal, then lift the subT tree up 
    | length sf == 1 && dTType rootT == ( dTType.fromJust.dTRootLabel ) subT && dTName rootT == ( dTName.fromJust.dTRootLabel ) subT 
        = DTNode ( dTRootLabel subT ) ( dTSubForest subT ) 
--    handle the Day ModifiedJulianDay case 
    | length sf == 1 && dTType rootT == ( dTType.fromJust.dTRootLabel ) subT && dTName rootT == "Day" && ( dTName.fromJust.dTRootLabel ) subT == "ModifiedJulianDay" 
        = DTNode ( dTRootLabel subT ) ( dTSubForest subT ) 
--    replace (:) + Char with [Char] 
    | length sf == 1 && dTName rootT == "(:)" && ( dTName.fromJust.dTRootLabel ) subT == "Char" 
        = DTNode ( Just ( dTDefault { dTName = "[Char]" } ) ) [] 
--    lifts list monad up one 
    | dTType rootT == MonadDT && ( dTType.fromJust.dTRootLabel ) subT == MonadDT && ( head.dTName ) rootT == '[' && ( dTName.fromJust.dTRootLabel ) subT == "(:)"   
        = DTNode ( nthRoot 1 ( DTNode t sf ) ) ( nthForest 1 ( DTNode t sf ) )
--   lifts maybe monad up one 
    | dTType rootT == MonadDT && ( dTType.fromJust.dTRootLabel ) subT == MonadDT && ( ( take 5 ).dTName ) rootT == "Maybe" && ( dTName.fromJust.dTRootLabel ) subT == "Just"  
        = DTNode ( nthRoot 1 ( DTNode t sf ) ) ( nthForest 1 ( DTNode t sf ) )      
--    handles other Monads??, even though the names may differ 
--    | length sf == 2 && dTName rootT == "(:)" = DTNode t [( head sf )] 
--    else no change 
    | otherwise = DTNode t sf 
    where 
--    this is a safe head. 
        rootT = fromJust t 
        subT = head sf 
        
--    Removing the final (:) from a List subforest 
removeListEnd :: DTTree DT -> DTTree DT 
removeListEnd ( DTNode t sf ) 
--    ignore nothing nodes  
    | isNothing t = DTNode t sf 
-- if root and last sf are both (:), then retain head of subforest and drop off out subforest tail 
    | length sf == 2 && dTName rootT == "(:)" && dTType rootT == MonadDT && ( dTName.fromJust.dTRootLabel ) lastSF == "(:)" && ( dTType.fromJust.dTRootLabel ) lastSF == MonadDT 
    = DTNode t [subT]  
--    else no change 
    | otherwise = DTNode t sf 
    where 
--    this is a safe head. 
        rootT = fromJust t 
        subT = head sf 
        lastSF = last sf 

--    allocate accessorNames to subforest  
--    fixAccessor :: String -> DT -> DT   
allocateAccessorDT :: DTTree DT -> DTTree DT 
allocateAccessorDT ( DTNode t sf ) 
--    if these are true, just an id 
    | isNothing t = DTNode t sf 
    | dtt == [] = DTNode t sf 
    | ( not.gIsProductDT ) ft = DTNode t sf 
--    reach down and update the accessor in each tree of the sf 
    | gIsProductDT ft && length dtt == length sf  
        = DTNode t ( map ( \( ac,tr ) -> updateDTTreeRoot ( fixAccessor ac ) tr ) ( zip dtt sf ) )        
--    default to id 
    | otherwise = DTNode t sf 
    where 
        ft = fromJust t 
        dtt = dTConfields ft 

--    propagates flag into a DTTree DT ( eg monad flag ) 
dTIsInMonadDTTree :: DTTree DT -> DTTree DT 
dTIsInMonadDTTree dtTree 
    = treeFix getMonadState updateDT ( False,0 ) dtTree 
 
--    does this branch represent a list monad in a DTTree? 
isMonadBranch :: DTTree DT -> Bool 
isMonadBranch ( DTNode t sf ) 
    | isNothing t = False 
    | length sf == 0 = False 
    | dTType rootT == MonadDT && ( dTType.fromJust.dTRootLabel ) subT == MonadDT && ( head.dTName ) rootT == '[' && ( dTName.fromJust.dTRootLabel ) subT == "(:)" = True 
    | dTType rootT == MonadDT && ( dTType.fromJust.dTRootLabel ) subT == MonadDT && ( ( take 5 ).dTName ) rootT == "Maybe" && ( dTName.fromJust.dTRootLabel ) subT == "Just" = True     
    | otherwise = False
    where 
        rootT = fromJust t 
        subT = head sf 

monadHeight :: DTTree DT -> Int 
monadHeight = treeFold monadP 

monadP :: Maybe DT -> [Int] -> Int 
monadP dt ts 
    | isNothing dt = 0 + maxOr0 ts 
    | otherwise = ( if ( dTType.fromJust ) dt == MonadDT then 1 else 0 ) + maxOr0 ts 
    
--    applies the fix to the complex DT Tree for list monads 
--    handles lists 3 levels deep
branchMonadFix :: DTTree DT -> DTTree DT 
branchMonadFix ( DTNode t sf ) 
--    ignore nothing nodes  
    | isNothing t = DTNode t sf 
--    ignore empty forests 
    | length sf == 0 = DTNode t sf 
--    just treat all lists the same 
    | isList  
        = DTNode ( nthRoot 1 ( DTNode t sf ) ) ( nthForest 1 ( DTNode t sf ) )
--    restructure tree in reverse order from deepest List monad first 
--    this means these choices will be ignored 
--    | isList && ( monadHeight ( DTNode t sf ) ) == 6 
--        = DTNode ( nthRoot 1 ( DTNode t sf ) ) [DTNode ( nthRoot 3 ( DTNode t sf ) ) [DTNode ( nthRoot 5 ( DTNode t sf ) ) ( nthForest 5 ( DTNode t sf ) )]]  
--    | isList && ( monadHeight ( DTNode t sf ) ) == 4 
--        = DTNode ( nthRoot 1 ( DTNode t sf ) ) [DTNode ( nthRoot 3 ( DTNode t sf ) ) ( nthForest 3 ( DTNode t sf ) )]  
--    | isList && ( monadHeight ( DTNode t sf ) ) == 2 
--        = DTNode ( nthRoot 1 ( DTNode t sf ) ) ( nthForest 1 ( DTNode t sf ) )
--    restructure tree in for Maybe monad 
    | isMaybe 
--    && ( monadHeight ( DTNode t sf ) ) == 2 
        = DTNode ( nthRoot 1 ( DTNode t sf ) ) ( nthForest 1 ( DTNode t sf ) )    
    | otherwise = DTNode t sf 
    where 
        rootT = fromJust t 
        subT = head sf 
        isList = dTType rootT == MonadDT && ( dTType.fromJust.dTRootLabel ) subT == MonadDT && ( head.dTName ) rootT == '[' && ( dTName.fromJust.dTRootLabel ) subT == "(:)" 
        isMaybe = dTType rootT == MonadDT && ( dTType.fromJust.dTRootLabel ) subT == MonadDT && ( ( take 5 ).dTName ) rootT == "Maybe" && ( dTName.fromJust.dTRootLabel ) subT == "Just"         

-------------------------------------
--    provides a generic wrapper for things, so that their names can be compared 
--    provides a universal container for all types, enabling common filter and folding functions 
--    functions cannot be compared in Haskell 
--    general function equality is undecidable 
--    There is no Eq ( a -> b ) => ( a -> b ), as this is undecidable 
--    No instance for ( Eq ( a -> b ) ) arising from a use of `==' 
--    This wrapper allows the function names to be compared, as a proxy. 
data NamedA b c = NamedA { 
--    always store the type name here 
      namedAName :: String 
--    for functions, store the function name here. 
    , namedAValue :: b 
--    for simple type, always use id, otherwise put function here 
    , namedAFunction :: b -> c 
--    the source DT 
    , namedADT :: DT 
--    position of this field in a flattened list including constructors 
    , namedAFieldIndex :: Int 
--    position of this field in a flattened list excluding constructors 
    , namedAShowIndex :: Int 
--    field name ( to be used in header ) 
    , namedAAccessorName :: String 
--    is this field inside a Monad such as [] or Maybe?  
    , namedAIsInMonad :: Bool 
--    what level is this field in the type tree 
--    each ProductDT = +1; each CloseBracketDT = -1 
    , namedAMonadLevel :: Int     
--    string list for enum type checking 
    , namedAConfields :: [String] 
    } deriving (  Typeable  )  
    
namedADefault = NamedA "" undefined undefined dTDefault 0 0 "" False 0 [] 

--    ignore namedAFunction, namedAAccessorName and namedAConfields for equality     
instance Eq b => Eq ( NamedA b c ) where 
    NamedA a1 b1 _ d1 e1 f1 _ h1 i1 _ == NamedA a2 b2 _ d2 e2 f2 _ h2 i2 _ 
        = a1 == a2 && b1 == b2 && dTEq d1 d2 && e1 == e2 && f1 == f2 && h1 == h2 && i1 == i2 

--    order the NamedA on name only 
instance Ord b => Ord ( NamedA b c ) where 
    compare ( NamedA a1 _ _ _ _ _ _ _ _ _ ) ( NamedA a2 _ _ _ _ _ _ _ _ _ ) = compare a1 a2  

--    cannot show a function, but can show its name  
instance Show b => Show ( NamedA b c ) where 
    show ( NamedA a b _ d e f g h i j ) 
        = intercalate " : " ["NamedA b c ", show a, show b, show d, show e, show f, show g, show h, show i, show j] 
        
--    custom show to discover differences between NamedA versions 
--    ignore namedAConfields 
showNamedA :: Show b => NamedA b c -> String 
showNamedA na 
    = intercalate sepCharS [namedAName na, show ( namedAValue na ), showDT ( namedADT na ), show ( namedAFieldIndex na ), show ( namedAShowIndex na ), show ( namedAIsInMonad na ), show ( namedAMonadLevel na )] 
        
--    propagates useful DT data to the NamedA  
dt2NamedA :: DT -> NamedA a b -> NamedA a b 
dt2NamedA dt na = na { namedADT = dt, namedAFieldIndex = dTFieldIndex dt, namedAShowIndex = dTShowIndex dt, namedAAccessorName = if isNothing dta then "" else fromJust dta, namedAIsInMonad = dTIsInMonad dt, namedAMonadLevel = dTMonadLevel dt, namedAConfields = dTConfields dt } 
    where dta = dTAccessor dt 

--    true if the field is a Base or Enum Type, False if it is a Product Type    
gIsField :: NamedA b c -> Bool 
gIsField = gIsFieldDT.namedADT 

--    true if a field or Date Product 
gIsFieldOrDate :: NamedA b c -> Bool 
gIsFieldOrDate n 
    = gIsFieldDT dt || gIsProductDT dt && dTName dt == "ModifiedJulianDay" 
    where dt = namedADT n 
    
--    embedded into a Tree 
gIsDayNode :: DTTree ( NamedA b c ) -> Bool 
gIsDayNode ( DTNode t sf ) 
--    make it safe 
    | isNothing t = False 
--    check the constructor name 
    | otherwise = ( ( == "ModifiedJulianDay" ).dTName.namedADT.fromJust ) t 
    
--    embedded into a Tree 
gIsListNode :: DTTree ( NamedA b c ) -> Bool 
gIsListNode ( DTNode t sf ) 
--    make it safe 
    | isNothing t = False 
--    check the constructor name 
    | otherwise = ( ( == "(:)" ).dTName.namedADT.fromJust ) t 
    
--    embedded into a Tree 
gIsMaybeNode :: DTTree ( NamedA b c ) -> Bool 
gIsMaybeNode ( DTNode t sf ) 
--    make it safe 
    | isNothing t = False 
--    check the constructor name 
    | otherwise = ( ( == "Just" ).dTName.namedADT.fromJust ) t 

--    true if it is a Product Type    
gIsProduct :: NamedA b c -> Bool 
gIsProduct = gIsProductDT.namedADT 

--    true if it is a Product Type 
gIsCloseBracket :: NamedA b c -> Bool 
gIsCloseBracket = gIsCloseBracketDT.namedADT 

--    true if it is a Product Type     
gIsBracket :: NamedA b c -> Bool 
gIsBracket = gIsBracketDT.namedADT 
    
--    always true 
gAlways :: NamedA b c -> Bool 
gAlways _ = True  

-------------------------------------
--    helper functions 
--    ADT 
undefinedType :: Data a => String -> a 
undefinedType s = ( undefined::s ) 
    
-------------------------------------------
--    Strings 
--    splits string on tabs 
wordsTab :: String -> [String]
wordsTab s =  case dropWhile isTab s of
            "" -> []
            s' -> w : wordsTab s''
                where ( w, s'' ) = break isTab s'

isTab :: Char -> Bool 
isTab c = c == '\t' 

sepCharS :: String 
sepCharS = "\t" 

--    base functions  
--    add brackets to a string 
brackets :: String -> String 
brackets s = "( " ++ s ++ " )" 

bracketsOpen :: String -> String 
bracketsOpen s = "( " ++ s  

bracketsClose :: String -> String 
bracketsClose s = s  ++ " )" 

--    removes rid of duplicate spaces 
--    rewrite using filterSnd? 
dedupSpace :: [Char] -> [Char] 
dedupSpace = filterSnd isTupleSpace
--    dedupSpace [] = [] 
--    dedupSpace [x] = [x] 
--    dedupSpace ( x:y:zs ) 
--    | isSpace x && isSpace y = dedupSpace ( y:zs ) 
--    | otherwise = x : dedupSpace ( y:zs ) 

isTupleSpace :: ( Char,Char ) -> Bool 
isTupleSpace ( x,y ) = isSpace x && isSpace y 

dedupTab :: [Char] -> [Char] 
dedupTab = filterSnd isTupleTab 

isTupleTab :: ( Char,Char ) -> Bool 
isTupleTab ( x,y ) = isTab x && isTab y 
    
-------------------------------------
--    this is the Undefined version using gunfold 
--    a separate composable function to serialise or flatten the undefined ADT into a list of data types and constructors 
--    flattening a tree using depth based traversal 
--    needed for input/output processing 
--    enables the hylomorphism pattern; this creates a mappable list that can be folded. 
--    this either captures, simplifies or discards the underlying tree structure to produce a usable list  
    
--   new entry point to flatten undefined tree 
gADTU2ListU ::  Data a => a -> [DT] 
gADTU2ListU a   
--    | trace ( "gADTU2ListU: [DT] = " ++ intercalate " : " ( map show dl )  ) False = undefined 
--    | trace ( "gADTU2ListU: DTTree DT  = " ++ show dt  ) False = undefined 
    | otherwise = dl 
        where 
            dl = updatedTFieldIndex2 ( flattenDFS dt ) 
            dt = gADTU2Tree a 
    
--   entry point for undefined tree  
gADTU2Tree ::  Data a => a -> DTTree DT 
gADTU2Tree a 
--    | trace ( "gADTU2Tree: dt = " ++ show dt  ) False = undefined 
--    | trace ( "gADTU2Tree: dt1 = " ++ show dt1  ) False = undefined 
--    | trace ( "gADTU2Tree: dt2 = " ++ show dt2  ) False = undefined 
--    | trace ( "gADTU2Tree: dt3 = " ++ show dt3  ) False = undefined     
    | otherwise = dTIsInMonadDTTree ( mapTree ( appendBracketDTTree.allocateAccessorDT ) dt3 ) 
    where 
        dt = gADTU2TreeRoot a ( describe_type [] a ) 
        dt1 = filterForest isNotNothingDTNode dt 
        dt2 = mapTree removeListEnd dt1 
        dt3 = mapTree fixDTnode dt2 
--        dt3 = branchReplace isMonadBranch branchMonadFix dt2 

--    from TRepTree to DTTree 
gADTU2TreeRoot :: Data a => a -> TRepTree -> DTTree DT 
gADTU2TreeRoot a ( TData tRep ctors ) 
--    | trace ( "gADTU2TreeRoot: tRep = " ++ show tRep ++ " : isTRepBaseType = " ++ show ( isTRepBaseType tRep ) ++ " : isTRepMonad = " ++ show ( isTRepMonad tRep ) ++ " : isTRepProdSum = " ++ show ( isTRepProdSum tRep ) ++ " : isTConEnumType = " ++ show ( ( and ( map isTConEnumType ctors ) ) ) ++ " : ctors = " ++ show ctors  ) False = undefined 
--    set the last ctor finalBracket True; otherwise False  
--    if a base type, just show the default 
    | isTRepBaseType tRep = DTNode ( Just ( tRep2BaseDT tRep ) ) []
--    if an Enum Type, show the enum type name  
    | length ctors > 0 && ( and ( map isTConEnumType ctors ) ) = DTNode ( Just ( dTDefault { dTName = c, dTType = EnumDT, dTConfields = map ( \( TCon ctor _ ) -> show ctor ) ctors } ) ) [] 
--    no ctors; do nothing 
    | length ctors == 0 = DTNode Nothing [] 
--    monad node 
    | isTRepMonad tRep = DTNode ( Just ( dTDefault { dTName = c, dTType = MonadDT } ) ) ( map ( gADTU2TreeRecurse a ) ctors ) 
--    assume this is a product 
    | otherwise = DTNode ( Just ( dTDefault { dTName = c, dTType = ProductDT } ) ) ( map ( gADTU2TreeRecurse a ) ctors )  
--    at least 1 ctor; dive into Product ADT  eg Day, Bucket 
--    | otherwise = DTNode Nothing ( map ( gADTU2TreeRecurse a ) ctors )  
    where c = show tRep 
--    ignore BackRef 
gADTU2TreeRoot _ _ = DTNode Nothing [] 

--    used to make the undefined and defined ADT 2 List match up 
tRep2BaseDT :: TRep -> DT 
tRep2BaseDT t 
    | st == "Integer" = dTDefault { dTName = "Int" } 
    | otherwise = dTDefault { dTName = st } 
    where st = show t 

--    old version without the intermediate DTTree 
--    example: gADTU2ListOld ( undefined::I2NDIn ) = I2NDIn I2NDIn [Char] Int 
gADTU2ListOld ::  Data a => a -> [DT] 
gADTU2ListOld a 
    | otherwise = gADTURoot a ( describe_type [] a  ) 
    
--    recurse isTConMonad
--    discovers monad and product types  
gADTU2TreeRecurse :: Data a => a -> TCon -> DTTree DT 
gADTU2TreeRecurse a ( TCon ctor tReps ) 
--    | trace ( "gADTU2TreeRecurse: ctor = " ++ show ctor ++ " : tReps = " ++ intercalate " " ( map show tReps )  ) False = undefined 
--    skip over empty reps 
    | length tReps == 0 = DTNode Nothing [] 
--    disregard empty monad constructors 
--    | elem c ["Nothing","[]"] = DTNode Nothing [] 
--    define monad DT and recurse 
    | elem c ["Just","(:)"] = DTNode ( Just ( dTDefault { dTName = c, dTType = MonadDT } ) ) ( map ( gADTU2TreeRoot a ) tReps ) 
--    else it must be a product and recurse 
    | otherwise = DTNode ( Just ( dTDefault { dTName = c, dTType = ProductDT } ) ) ( map ( gADTU2TreeRoot a ) tReps ) 
    where c = show ctor 
    
--    flatten the ADT recursively     
gADTURoot :: Data a => a -> TRepTree -> [DT] 
gADTURoot a ( TData tRep ctors ) 
--    | trace ( "gADTURoot: tRep = " ++ show tRep ++ " : isTRepBaseType = " ++ show ( isTRepBaseType tRep ) ++ " : isTConEnumType = " ++ show ( ( and ( map isTConEnumType ctors ) ) ) ++ " : ctors = " ++ show ctors  ) False = undefined 
--    set the last ctor finalBracket True; otherwise False  
--    if a base type, just show the default 
    | isTRepBaseType tRep = [tRep2BaseDT tRep] 
--    if an Enum Type, show the Enum type name  
    | length ctors > 0 && ( and ( map isTConEnumType ctors ) ) = [dTDefault { dTName = ( show tRep ), dTType = EnumDT, dTConfields = ( map ( \( TCon ctor _ ) -> show ctor ) ctors ) }] 
--    no ctors; do nothing 
    | length ctors == 0 = [] 
--    at least 1 ctor; dive into ADT  eg Day, Bucket 
    | otherwise = concatMap ( gADTURecurse a ) ctors 
--    ignore BackRef 
gADTURoot _ _ = [] 

--    recurse 
--    handles monad or product types 
gADTURecurse :: Data a => a -> TCon -> [DT] 
gADTURecurse a ( TCon ctor tReps ) 
--    | trace ( "gADTURecurse: ctor = " ++ show ctor ++ " : tReps = " ++ intercalate ' ' ( map show tReps )  ) False = undefined 
--    disregard empty monad constructors 
    | elem c ["Nothing","[]"] = [] 
--    define monad DT and recurse 
    | elem c ["Just","(:)"] = [( dTDefault { dTName = c, dTType = MonadDT } )] ++ concatMap ( gADTURoot a ) tReps 
--    else it must be a product and recurse
    | otherwise = [dTDefault { dTName = c, dTType = ProductDT }] ++ concatMap ( gADTURoot a ) tReps 
    where c = show ctor 
    
------------------------------
--    this is the defined version using gfold or gmapQ 
--    a separate composable function to serialise or flatten the undefined ADT into a list of data types and constructors 
gADTD2ListD ::  Data a => a -> [DT] 
gADTD2ListD a 
    = updatedTFieldIndex2 ( flattenDFS ( gADTD2Tree a ) ) 

--    entry point for conversion to DTTree 
--    Nothing nodes introduced by [] are filtered out 
gADTD2Tree :: Data a => a -> DTTree DT  
gADTD2Tree a 
--    | trace ( "gADTD2Tree: t = " ++ show dt  ) False = undefined 
    | otherwise = dTIsInMonadDTTree ( mapTree ( appendBracketDTTree.allocateAccessorDT ) dt3 )  
    where 
        dt = gADTD2TreeRoot a 
        dt1 = filterForest isNotNothingDTNode dt 
--    clears out trailing list 
        dt2 = mapTree removeListEnd dt1 
        dt3 = mapTree fixDTnode dt2 
--        dt3 = branchReplace isMonadBranch branchMonadFix dt2 

--    using the standard pattern 
gADTD2TreeRoot :: Data a => a -> DTTree DT  
gADTD2TreeRoot a = gADTD2TreeRecurse a 

--    using the standard pattern 
gADTD2TreeRecurse :: Data a => a -> DTTree DT  
gADTD2TreeRecurse a 
--    | trace ( "gADTD2TreeRecurse: tycon = " ++ show tycon ++ " : datarep = " ++ show datarep  ) False = undefined 
    | otherwise = DTNode ( gADTD2DataTypeRep a ) ( gmapQ gADTD2TreeRoot a ) 
    where 
        t = dataTypeOf a 
        tycon = dataTypeName t
        datarep = dataTypeRep t 
        
--    use datarep to extract constructor names. 
--    Each datarep is a tag for later mapping. 
gADTD2DataTypeRep :: Data a => a -> Maybe DT 
gADTD2DataTypeRep a 
--    | trace ( "gADTD2DataTypeRep: tycon = " ++ show tycon ++ " : datarep = " ++ show datarep  ) False = undefined 
    | otherwise = case datarep of 
--    order matters, as the program traverses down the tree 
--    cs = [Constr] 
--    AlgRep cs -> gADTD2AlgRep a 
--    if length confields == 0 then ( map show cs ) else [] 
    AlgRep cs -> gADTD2AlgRep a 
--    ++ if length cs == 0 then [] else map gConstr2DT cs 
--    IntRep -> [DT "Int" BaseDT [] 0 True True False] 
--    FloatRep -> [DT "Float" BaseDT [] 0 True True False] 
--    Char is quite rare, so will be ignored. 
--    CharRep -> [DT "[Char]" BaseDT [] 0 True True False] 
    IntRep -> Just ( dTDefault { dTName = "Int" } ) 
    FloatRep -> Just ( dTDefault { dTName = "Float" } ) 
--    Char is quite rare, so will be ignored. 
    CharRep -> Just ( dTDefault { dTName = "Char" } )  
--    always false     
    NoRep -> Nothing 
    where 
        t = dataTypeOf a  
        tycon = dataTypeName t 
        datarep = dataTypeRep t 

--    allocates a string to String function for each valid input 
--    add additional tycon as new Algrep are discovered  
gADTD2AlgRep :: Data a => a -> Maybe DT 
gADTD2AlgRep a  
--    | trace ( "gADTD2AlgRep: tycon = " ++ show tycon ++ " : datarep = " ++ show datarep ++ " : confields = " ++ show confields  ) False = undefined 
--    cs == datarep! 
--    simplify Bools 
    | tycon == "Prelude.Bool" = Just ( dTDefault { dTName = "Bool" } ) 
    | tycon == "Bool" = Just ( dTDefault { dTName = "Bool" } ) 
--    add monad types here. Use the main constructor as dTName 
    | tycon == "Prelude.[]" = Just ( dTDefault { dTName = "(:)", dTType = MonadDT  } ) 
    | tycon == "Prelude.Maybe" = Just ( dTDefault { dTName = "Just", dTType = MonadDT  } ) 
--    an Enum type is one without named fields. 
--    mark as Show enum name and types. 
    | length confields == 0 = Just ( dTDefault { dTName = tycon, dTType = EnumDT, dTConfields = ( map show dtcfields ) } )  
--    check for complex types, with named fields 
--    show the head constructor; head is now safe 
--    e.g. ModifiedJulianDay will be shown but not Day. 
--    skip over the data type, and show the first constructor + confields. This will prevent duplicates.  
    | length confields > 0 = Just ( dTDefault { dTName = if dtcfields == [] then "No dataTypeConstrs" else ( show ( head dtcfields ) ), dTType = ProductDT, dTConfields = confields } )  
--    default to false, to ensure all cases are caught 
    | otherwise = Nothing 
    where 
        t = dataTypeOf a  
        tycon = dataTypeName t 
        datarep = dataTypeRep t 
--    head is now safe 
        dtcfields = if isAlgType t then dataTypeConstrs t else [] 
        confields = if dtcfields == [] then [] else ( constrFields.head ) dtcfields 
        
--    Older version without the intermediate DTTree structure 
--    a separate composable function to serialise or flatten the undefined ADT into a list of data types and constructors 
gADTD2ListOld ::  Data a => a -> [DT] 
gADTD2ListOld a 
    = gADTD2Root a 
    
--    root of ADT tree  
--    calls recurse to go down into ADT tree 
gADTD2Root :: Data a => a -> [DT] 
gADTD2Root a 
--    | trace ( "gADTD2Root: dataTypeOf t = " ++ show t ++ " : tycon = " ++ show tycon  ) False = undefined 
    | otherwise = gADTD2Recurse a     
    where 
        t = dataTypeOf a 
        tycon = dataTypeName t

--    recurses back so that it traverse the whole data type tree  
--    compose these together into a function list 
gADTD2Recurse :: Data a => a -> [DT] 
gADTD2Recurse a 
--    | trace ( "gADTD2Recurse: tycon = " ++ show tycon ++ " : datarep = " ++ show datarep  ) False = undefined 
    | otherwise = concat [maybeToList ( gADTD2DataTypeRep a ), concat ( gmapQ gADTD2Root a )] 
    where 
        t = dataTypeOf a 
        tycon = dataTypeName t 
        datarep = dataTypeRep t 

-------------------------------------------------------------------------------- 
--    all about Enum 
--    used to validate Enum values as strings 
data EnumLU = EnumLU { 
      enumLUName :: String  
    , enumLUValues :: [String] 
    } deriving (  Eq, Ord, Typeable, Show, Read  ) 
    
--    builds a single Enum record 
makeEnumLU :: Data a => a -> EnumLU 
makeEnumLU a 
--    = EnumLU ( gname a ) ( gelemsU a )  
    = EnumLU ( gname a ) ( gelemsD a )      
    
--    convert to KV format     
enumLU2KV :: EnumLU -> ( String, [String] ) 
enumLU2KV e = ( enumLUName e, enumLUValues e )  

--    create a type checking function for a Enum type using gmapQ 
--    replaces thFunBuildCheckSumADT
--    Example 
--    fileTypeCheck :: String -> Bool 
--    fileTypeCheck = flipElem ["CSV", "DDL", "DML", "HTM", "SQL", "TSV", "TXT", "XMLOut", "TDS"]
--    called from fileTest in Input.hs 
--    this serialise all types to a Bool 
--    needed to test before loading 

--    test accessors 
--    gmapQ dataTypeOf dBType2WDefault -> [DataType {tycon = "DBType2", datarep = AlgRep [ORACLE2,NETEZZA2,XSD2,OBIEE2]}] 
--    dataTypeOf dBType2WDefault -> DataType {tycon = "DBType2W", datarep = AlgRep [DBType2W]} ( missing values ) 
--    dataTypeRep ( head ( gmapQ dataTypeOf dBType2WDefault ) ) -> AlgRep [ORACLE2,NETEZZA2,XSD2,OBIEE2]

--    entry:  a universal Enum check function. 
--    example: 
--    gcheckEnumTypeD ( undefined::DBType2 ) X = False
--    gcheckEnumTypeD ( undefined::DBType2 ) OBIEE2 = True
gcheckEnumTypeD :: Data a => a -> String -> Bool 
gcheckEnumTypeD a s  
--    | trace ( "gcheckEnumTypeD: ( gelemsD a ) = " ++ show ( gelemsD a ) ++ " : s = " ++ s ) False = undefined 
    | otherwise = ( flip elem ) ( gelemsD a ) s 

--    entry: returns Enums only or an empty list 
--    no traversal down the ADT's AST 
gelemsD :: Data a => a -> [String] 
gelemsD t 
    | enums == [] = [] 
    | otherwise = enums  
    where enums = gelemDList t  
    
--    use datarep to extract constructor names 
--    These are only in the AlgRep datarep records, in the dataTypeRep record. 
--    All other datarep are set to the empty list.  
gelemDList :: Data a => a -> [String]   
gelemDList a  
--    | trace ( "gelemDList: dataTypeRep = " ++ show ( ( dataTypeRep.dataTypeOf ) t ) ) False = undefined 
    | otherwise 
      = case dataTypeRep t of 
        AlgRep cs -> if length confields == 0 then ( map ( trim.show ) cs ) else [] 
        IntRep -> []
        FloatRep -> []
        CharRep -> [] 
        NoRep -> [] 
    where 
        t = dataTypeOf a 
--        confields = if isAlgType t then ( constrFields.head.dataTypeConstrs ) t else [] 
--    head is now safe 
        dtcfields = if isAlgType t then dataTypeConstrs t else [] 
        confields = if dtcfields == [] then [] else ( constrFields.head ) dtcfields 
    
--    old TH generated code; one function fer each Enum type!  
--    string2SourceType :: String -> Either String SourceType  
--    string2SourceType s 
--        | not ( sourceTypeCheck trimS ) = Left ( "Error! string2SourceType? string is not a valid SourceType: " ++ trimS ) 
--        | otherwise = Right ( read trimS ) 
--        where trimS = trim s 

--    entry:  another universal Enum check function. 
--    works with an undefined type 
--    gcheckEnumTypeU ( undefined::DBType2 ) "X" = False 
--    gcheckEnumTypeU ( undefined::DBType2 ) "OBIEE2" = True 
gcheckEnumTypeU :: Data a => a -> String -> Bool 
gcheckEnumTypeU a s  
--    | trace ( "gcheckEnumTypeU: ( gelemsU a ) = " ++ show ( gelemsU a ) ++ " : s = " ++ s ) False = undefined 
    | otherwise = ( flip elem ) ( gelemsU a ) s 
    
--    check if this is an Enum type 
--     Ambiguous type variable a0 arising from a use of gelemsU
--      prevents the constraint ( Data a0 ) from being solved.
--isEnumType :: String -> Bool 
--isEnumType s 
--    | ( gelemsU ( undefined::s ) ) == [] = False 
--    | otherwise = True 

--    entry: alternate gunfold gelemsD 
--    provides a list of Enum types as strings 
gelemsU :: Data a => a -> [String]  
gelemsU a = geURoot ( describe_type [] a ) 
    
--    base of data type AST 
--    if base is not an Enum type, return [] 
geURoot :: TRepTree -> [String] 
geURoot ( TData tRep ctors ) 
--    | trace ( "gdRoot: tRep = " ++ show tRep ++ " : gdIsBaseTRep = " ++ show ( gdIsBaseTRep tRep ) ++ " : isTConEnumType = " ++ show ( ( and ( map isTConEnumType ctors ) ) ) ) False = undefined 
--    if an Enum Type, map all elements into strings : helper fn? 
    | length ctors > 0 && ( and ( map isTConEnumType ctors ) ) = map geURecurse ctors 
--    otherwise this is not an Enum Type, and ignore 
    | otherwise = [] 
--    ignore BackRef 
geURoot _ = [] 

--    NO recursion back - simple map only 
geURecurse :: TCon -> String 
geURecurse ( TCon ctor tReps ) 
--    | trace ( "gdRoot: ctor = " ++ show ctor  ) False = undefined 
    | otherwise = sc  
    where sc = show ctor
    
---------------------------- 
--    generic default for undefined types 
gdefaultU :: Data a => a -> a 
gdefaultU a 
--    this is the UNSAFEST head in all the code 
--    head: empty list can be triggered by a Monad such as (:) or Maybe 
--    Look for unused or unusual Monads in the data type 
--    | trace ( "gdefaultU: gdU a = " ++ s  ) False = undefined 
    | otherwise = ( fst.head.gread ) s 
    where s = gdS a 

--    generic default for a defined type  USELESS 
gdefaultD :: ( Data a, Show a ) => a -> a 
gdefaultD a 
--    | trace ( "gdefaultD: gdD a = " ++ show ( gdD a )  ) False = undefined 
--    | otherwise = ( fst.head.gread.gdD ) a 
--    an UNSAFE head! 
    | otherwise = ( fst.head.gread.gshow ) a 
    
--    simple wrapper 
--    converts a type into a default string 
gdS :: Data a => a -> String  
gdS = gd2S.gdU 

--    converts a type into a default string list 
gdSL :: Data a => a -> [String]   
gdSL = gd2SL.gdU 
    
--    common fn to convert namedA to final string 
gd2S :: [NamedA String String] -> String 
gd2S ns = trim ( ( foldr ( . ) id ( intercalate [showChar ' '] [( map namedAFunction ns )] ) ) "" ) 

--    common fn to convert namedA to a default string list 
gd2SL :: [NamedA String String] -> [String]  
gd2SL ns = map ( \n -> ( namedAFunction n ) "" ) ns 

--    from an undefined type 
--    gADTU2ListU :: Data a => a -> [DT] 
gdU :: Data a => a -> [NamedA String String]  
gdU a 
--    | trace ( "gdU: ns = " ++ map show ns  ) False = undefined 
    | otherwise = ns 
    where ns = gd gADTU2ListU a 
 
--    from a defined type 
--    gADTD2ListD :: Data a => a -> [DT] 
gdD :: Data a => a -> [NamedA String String]  
gdD a 
--    | trace ( "gdD: ns = " ++ map show ns  ) False = undefined 
    | otherwise = ns 
    where ns = gd gADTD2ListD a 
    
--    initial call to traverse ADT AST to build up a default record 
--    gd :: Data a => ( a -> [DT] ) -> a -> String  
gd :: Data a => ( a -> [DT] ) -> a -> [NamedA String String]   
gd f a 
--    | trace ( "gd: ns = " ++ map show ns  ) False = undefined 
    | otherwise = ns 
    where ns = mapSnd fixDefaults ( map type2Default ( f a ) )
--    where ns = ( foldr ( . ) id ( intercalate [showChar ' '] [( map namedAFunction ( mapSnd fixDefaults ( map type2Default ( f a ) ) ) )] ) ) "" 
    
--    simple default 
--    id function will force b to be Int as well   
namedAString = namedADefault { namedAValue = bracketsOpen " ", namedAFunction = showString " ( " } 

--    allocate a the type name and value for each type    
--    TRep defaults   
--    gdU ( undefined::Bucket ) = " ( Bucket  ( 0 )   ( SQL2 )   ( 0.0 )   ( False )   \" \"  (  ModifiedJulianDay  (  40587  )  )  ) " 
type2Default :: DT -> NamedA String String 
type2Default dt 
--    | trace ( "type2Default: dTName = " ++ n ++ " : dTType = " ++ show t ++ " : dTConfields = " ++ show dtcs  ) False = undefined 
--    A string with a space is needed to avoid head on an empty list 
    | n == "[Char]" = na { namedAName = "[Char]", namedAValue = defaultString, namedAFunction = showString " ( \" \" )" } 
--    ( showChar '( '.showChar 'z'.showChar ' )' ) 
    | n == "Char" = na { namedAName = "Char", namedAValue = defaultChar, namedAFunction = showString " ( ' ' )" }  
    | n == "Int" = na { namedAName = "Int", namedAValue = defaultInt, namedAFunction = showString " ( 0 )" } 
    | n == "Integer" = na { namedAName = "Integer", namedAValue = defaultInt, namedAFunction = showString " ( 0 )" } 
    | n == "Float" = na { namedAName = "Float", namedAValue = defaultFloat, namedAFunction = showString " ( 0.0 )" } 
    | n == "Double" = na { namedAName = "Double", namedAValue = defaultFloat, namedAFunction = showString " ( 0.0 )" }     
    | n == "Bool" = na { namedAName = "Bool", namedAValue = defaultBool, namedAFunction = showString " ( False )" } 
--    handle Monads 
--    | n == "Just" = na { namedAName = n, namedAValue = brackets "Nothing", namedAFunction = showString " ( Nothing )" } 
--    | n == "(:)" = na { namedAName = n, namedAValue = brackets "[]", namedAFunction = showString " ( [] )" } 
    | n == "Just" = na { namedAName = n, namedAValue = bracketsOpen "Just", namedAFunction = showString " ( Just " } 
    | n == "(:)" = na { namedAName = n, namedAValue = bracketsOpen n, namedAFunction = showString " ( (:) " } 
--    identify Enum type, and take first element 
    | t == EnumDT = na { namedAName = n, namedAValue = brackets defEnum, namedAFunction = ( showString " ( ".showString defEnum.showString " ) " ) } 
--    handle product types; closing brackets are below  
    | t == ProductDT = na { namedAName = n, namedAValue = bracketsOpen n, namedAFunction = showString ( " (  " ++ n ) } 
--    hand close list bracket     
    | t == CloseListBracketDT = na { namedAName = show t, namedAValue = bracketsClose " ( [] )", namedAFunction = showString " ( [] ) ) " }     
--    handle bracket types - always 0  
    | t == CloseBracketDT = na { namedAName = show t, namedAValue = bracketsClose " ", namedAFunction = ( showString "  )" ) } 
--    should not occur 
    | otherwise = na { namedAName = concat ["Error! type2Default? dTName = ",n, " : dTType = ",show t, " : dTConfields = ",concat dtcs],namedAValue = "" }  
    where 
        n = dTName dt 
        t = dTType dt 
        dtcs = dTConfields dt 
--    this is a safe head. 
        defEnum = if dtcs == [] then "" else head dtcs 
        na = dt2NamedA dt namedAString 

--    modify the value for d2 to 40587 or 1970-01-01 or epochDay for product type ModifiedJulianDay
--    this function can be called by mapSnd :: ( ( a,a ) -> a ) -> [a] -> [a] 
fixDefaults :: NamedA String String -> NamedA String String -> NamedA String String 
fixDefaults d1 d2 
--    fix d2 if followed by date 
    | namedAName d1 == "ModifiedJulianDay" = d2 { namedAValue = "( 40587 )", namedAFunction = showString " ( 40587 )" } 
    | otherwise = d2 
        
--    shared defaults for gfold and gunfold versions  
defaultChar = " " 
defaultString = " "
defaultInt = "( 0 )" 
defaultFloat = "( 0.0 )" 
defaultBool = "( False )" 

-------------------
--    don't use, as cannot inspect an undefined type 
--    shows initial default name followed by all accessors sepCharS
gdefaultQ :: Data a => a -> a  
gdefaultQ a  
--    this is the UNSAFEST head in all the code 
--    head: empty list can be triggered by a Monad such as (:) or Maybe 
--    Look for unused or unusual Monads in the data type 
--    | trace ( "gdefaultQ: ( gdQ.gdefaultU ) a = " ++ s  ) False = undefined 
    | otherwise = ( fst.head.gread ) s  
    where s = ( gdQ.gdefaultU ) a 

--    shows initial default name followed by all accessors sepCharS
gdQ :: Data a => a -> String 
gdQ a = intercalate " " ( gdefault2 a ) 

--gdefault2 :: ( Foldable a, Data a ) => a -> [String] 
gdefault2 :: Data a => a -> [String] 
gdefault2 a 
--    | trace ( "gdefault2: ss = " ++ intercalate sepCharS ss  ) False = undefined 
    | otherwise = ss 
    where ss = ( gdefaultRecurse2 `ext1Q` gdefaultList2 `ext1Q` gdefaultMaybe2 `extQ` gdefaultString2 `extQ` gdefaultChar2 `extQ` gdefaultInt2 `extQ` gdefaultBool2 `extQ` gdefaultFloat2 `extQ` gdefaultDay2 `extQ` gdefaultInteger2 `extQ` gdefaultDouble2 `extQ` gdefaultUTCTime2 `extQ` gdefaultFileType2 `extQ` gdefaultSourceType2 ) a  
--    
--    show ( ( dataTypeRep.dataTypeOf ) a ) = AlgRep [I2NDIn] 
--    but undefined Constr 
gdefaultRecurse2 :: Data a => a -> [String] 
gdefaultRecurse2 a 
--    | trace ( "gdefaultRecurse2: st = " ++ st  ) False = undefined 
    | otherwise = ["( ",st] ++ concat ( gmapQ gdefault2 a ) ++ [" )"] 
    where st = ( dataTypeName.dataTypeOf ) a 
--    where st = ( dataTypeName.dataTypeOf ) a ++ " "    
    
--    list monad 
gdefaultList2 :: Data a => [a] -> [String]  
gdefaultList2 _ = ["( [] )"] 
--    = [ "[" ++ concat ( intersperse "," ( concatMap gdefault2 ls ) ) ++ "]" ] 
    
--    maybe monad 
gdefaultMaybe2 :: Data a => Maybe a -> [String]  
gdefaultMaybe2 _ = ["( Nothing )"] 
--    | isNothing ma = [ "( Nothing )" ] 
--    | otherwise = gdefault2 ( fromJust ma ) 
    
gdefaultString2 :: String -> [String] 
gdefaultString2 _ = ["( \" \" )"] 

gdefaultChar2 :: Char -> [String] 
gdefaultChar2 _ = ["( ' ' )"] 

gdefaultBool2 :: Bool -> [String] 
gdefaultBool2 _ = ["( False )"] 

gdefaultInt2 :: Int -> [String] 
gdefaultInt2 _ = ["( 0 )"] 

gdefaultInteger2 :: Integer -> [String] 
gdefaultInteger2 _ = ["( 0 )"] 

gdefaultFloat2 :: Float -> [String] 
gdefaultFloat2 _ = ["( 0.0 )"]

gdefaultDouble2 :: Double -> [String] 
gdefaultDouble2 _ = ["( 0.0 )"]

gdefaultDay2 :: Day -> [String] 
gdefaultDay2 _ = ["( 40587 )"] 

gdefaultUTCTime2 :: UTCTime -> [String] 
gdefaultUTCTime2 _ = ["( "++ show epochUTCTime ++ " )"] 

--    !!! NOTE these need to hard coded for each Enum Sum type 
--    so this is not as usable as the gdS function 
gdefaultFileType2 :: FileType -> [String] 
gdefaultFileType2 _ = ["( TSV )"] 

gdefaultSourceType2 :: SourceType -> [String] 
gdefaultSourceType2 _ = ["( SYS )"] 




-------------------------
--    initial call to count constructors in an ADT AST 

--    from an undefined type 
gcountShowU :: Data a => a -> Int  
gcountShowU  a = gcountShow  gADTU2ListU a 
    
--    from a defined type 
gcountShowD :: Data a => a -> Int  
gcountShowD  a = gcountShow  gADTD2ListD a 

--    from an undefined type 
gcountFieldU :: Data a => a -> Int  
gcountFieldU  a = gcountField  gADTU2ListU a 
    
--    from a defined type 
gcountFieldD :: Data a => a -> Int  
gcountFieldD  a = gcountField  gADTD2ListD a 

--    ... 
gcountShow :: Data a => ( a -> [DT] ) -> a -> Int
gcountShow  f a 
    = sum ( map ( namedAValue.type2Count ) ( f a ) ) 
    
--    now able to fold filter based on type name to enhance  
gcountField :: Data a => ( a -> [DT] ) -> a -> Int
gcountField  f a 
    = sum ( map ( gcFieldInt.type2Count ) ( f a ) ) 
    
--    1 if a field ( base or Enum ), 0, if not 
gcFieldInt :: NamedA Int Int -> Int 
gcFieldInt n 
    | ( gIsFieldDT.namedADT ) n = 1 
    | otherwise = 0 

--    count default 
--    id function will force b to be Int as well 
namedACount = namedADefault { namedAValue = 1, namedAFunction = id } 

--    allocate the type name and value for each type 
--    no need for special date processing, as this is a single number 
type2Count :: DT -> NamedA Int Int   
type2Count dt 
--    | trace ( "type2Count: dTName = " ++ n ++ " : dTType = " ++ show t ++ " : dTConfields = " ++ show dtcs  ) False = undefined 
--    if empty string is default, this will be ignored.  
--    so a string with a space is needed 
    | n == "[Char]" = na2 
    | n == "Char" = na2  
    | n == "Int" = na2 
    | n == "Integer" = na2 
    | n == "Float" = na2 
    | n == "Double" = na2     
    | n == "Bool" = na2 
--    monads 
    | n == "Just" = na2 
    | n == "(:)" = na2 
--    identify Enum type, and take first element 
    | t == EnumDT = na { namedAName = show t }   
--    handle product types 
    | t == ProductDT = na { namedAName = show t } 
--    handle bracket types - always 0 
    | t == CloseBracketDT = na { namedAName = show t, namedAValue = 0 } 
    | t == CloseListBracketDT = na { namedAName = show t, namedAValue = 0 } 
--    should not occur 
    | otherwise = na { namedAName = concat ["Error! type2Count? dTName = ", n, " : dTType = ", show t, " : dTConfields = ", concat dtcs], namedAValue = 0 }   
    where 
        n = dTName dt 
        t = dTType dt 
        dtcs = dTConfields dt 
        na = dt2NamedA dt namedACount 
        na2 = na { namedAName = n } 

------------------------------------
--    wraps gload in a greadF 
gloadU :: Data a => a -> [String] -> a 
gloadU  a xs 
    = greadF a ( gloadU2String a xs )  
    
gloadD :: Data a => a -> [String] -> a 
gloadD  a xs 
    = greadF a ( gloadD2String a xs )  
    
--    gload with error messages 
--    type failure will be picked up at compile time 
gloadEitherU :: Data a => a -> [String] -> Either String String 
gloadEitherU  a xs 
--    test empty 
    | xs == [] = Left "Error: no strings to load. " 
--    test count  
    | length xs /= gcountShowU  a = Left ( "Error: wrong number of fields: Expected = " ++ show ( gcountShowU  a ) ++ " : Actual = " ++ show ( length xs ) ++ " : Input = " ++ intercalate " " xs ) 
--    test if the each string can be transformed to the correct type     
--    | not ( gcheckU  a xs ) = Left ( "Error: at least one string fails the type check: " ++ gcheckTest3 ( gckU a ) xs )   
    | otherwise = Right ( gloadU2String  a xs ) 
    
--    constructs a readable string from a CSV input 
--    assumed to be for a single input data type 
--    type needed as different rules applied to String and Day 
--    converts a list of strings into a readable String for a type 
--    gloadD2String  i2NDInDefault i2NDINGood =  (  I2NDIn  ( I2NDIn )   "X"   ( 1 )   ) 
--    gloadD2String  bucketDefault bucketGood =  (  Bucket  ( Bucket )   ( 4 )   ( TSV2 )   ( 2.2 )   ( True )   "X"   ( ModifiedJulianDay )   ( 40600 )   ) 
--    not correct for Product types ! 
--    gldU :: Data a => a -> [NamedA String String] 
gloadU2String :: Data a => a -> [String] -> String 
gloadU2String  a xs 
--    | trace ( "gloadU2String: dTName = " ++ ( dataTypeName.dataTypeOf ) a ++ " : xs = " ++ show xs  ) False = undefined 
--    = " (  " ++ ( dataTypeName.dataTypeOf ) a ++ " " ++ intercalate ' ' ( map ( \( f,s ) -> f s ) ( zip ( map namedAFunction ( gldU  a ) ) xs ) ) ++ "  ) " 
    = gload2String ( gldU  a ) xs 
    
gloadD2String :: Data a => a -> [String] -> String 
gloadD2String  a xs 
--    | trace ( "gloadD2String: dTName = " ++ ( dataTypeName.dataTypeOf ) a ++ " : xs = " ++ show xs  ) False = undefined 
--    = " (  " ++ ( dataTypeName.dataTypeOf ) a ++ " " ++ intercalate ' ' ( map ( \( f,s ) -> f s ) ( zip ( map namedAFunction ( gldD  a ) ) xs ) ) ++ "  ) " 
    = gload2String ( gldD  a ) xs 
    
--    common function used by defined and undefined types 
--    simply fold in the xs using the ii index to each field
--    rebuild  with Constructors for the product types, and add  ) to end 
gload2String :: [NamedA String String] -> [String] -> String 
gload2String ns xs 
--    | trace ( "gload2String: length xs = " ++ show ( length xs ) ++ " : max namedAFieldIndex = " ++ show ( maximum ( map namedAFieldIndex ns ) ) ++ " : ns = " ++ concatMap show ns ++ " : xs = " ++ concat xs  ) False = undefined 
--   ensure a safety so that the !! does not go wrong, need to subtract 1 to get index 
    | length xs /= maximum ( map namedAFieldIndex ns ) = concat ["Error! gload2String? length xs = ", show ( length xs ), " : maximum = ", show ( maximum ( map namedAFieldIndex ns )  ) ] 
--    creates a function f [String] -> String 
    | otherwise = concatMap ( name2Function xs ) ns  
    
--    allocate a string argument to a function name 
name2Function :: [String] -> NamedA String String -> String 
name2Function xs na 
    = ( if gIsProduct na then nf "" ++ namedAName na ++ " " else " "  ) ++ ( if gIsField na then ( nf ( xs !! ( ( namedAFieldIndex na ) - 1 ) ) ) else " " ) ++ ( if gIsCloseBracket na then nf "" else " "  ) 
    where nf = namedAFunction na
  
--    testing function application  
--    shows function name and input string 
--gloadTest :: Data a => ( a -> [NamedA String String] ) -> a -> [String] -> String 
gloadTest :: [NamedA String String] -> [String] -> String 
gloadTest ns xs 
--    | trace ( "gloadTest: tycon = " ++ show ( ( dataTypeName.dataTypeOf ) a ) ++ " : datarep = " ++ show ( dataTypeRep a ) ) False = undefined 
--    | otherwise = " (  " ++ ( dataTypeName.dataTypeOf ) a ++ " " ++ intercalate ' ' ( map ( \( f,s ) -> " : " ++ f ++ " " ++ s  ) ( zip fns xs ) ) ++ "  ) " 
--   ensure a safety so that the !! does not go wrong, need to subtract 1 to get index 
    | length xs /= maximum ( map namedAFieldIndex ns ) = concat ["Error! gloadTest? length xs = ", show ( length xs ), " : maximum = ", show ( maximum ( map namedAFieldIndex ns )  ) ] 
--    | otherwise = intercalate ' ' ( map ( \( g,s ) -> " : " ++ g ++ " " ++ s  ) ( zip fns cxs ) ) 
    | otherwise = intercalate " " ( map ( name2Field xs ) ns ) 

--    enables the argument allocation to be transparent   
name2Field :: [String] -> NamedA String String -> String 
name2Field xs na 
    = ( if gIsProduct na then nf "" ++ namedAName na ++ " " else " "  ) ++ namedAValue na ++ ( if gIsField na then " (  xs !! " ++ show ii ++ "  ) = " ++ xs !! ii else " " ) ++ ( if gIsCloseBracket na then nf "" else " "  ) 
    where 
        ii = ( namedAFieldIndex na ) - 1 
        nf = namedAFunction na 

--    initial call to traverse ADT AST to load the fields  
--    need to fix date for ModifiedJulianDay 
gld :: Data a => ( a -> [DT] ) -> a -> [NamedA String String] 
gld  f a 
    = mapSnd fixDateLoad ( map type2Load ( f a ) ) 

--    from an undefined type 
gldU :: Data a => a -> [NamedA String String] 
gldU  a = gld  gADTU2ListU a 
    
--    from a defined type 
gldD :: Data a => a -> [NamedA String String]   
gldD  a = gld  gADTD2ListD a 

--    simple default 
namedALoad = namedADefault { namedAValue = "brackets", namedAFunction = brackets } 

--    TRep defaults   
type2Load :: DT -> NamedA String String  
type2Load  dt 
--    | trace ( "type2Load: dTName = " ++ n ++ " : dTType = " ++ show t ++ " : dTConfields = " ++ show dtcs  ) False = undefined 
--    if empty string is default, this will be ignored.  
--    so a string with a space is needed 
    | n == "[Char]" = na { namedAName = "[Char]", namedAValue = "gString2String", namedAFunction = gString2String }  
    | n == "Char" = na { namedAName = "Char", namedAValue = "gString2String", namedAFunction = gString2String }   
    | n == "Int" = na { namedAName = "Int", namedAValue = "gString2Num", namedAFunction = gString2Num }    
    | n == "Integer" = na { namedAName = "Integer", namedAValue = "gString2Num", namedAFunction = gString2Num }     
    | n == "Float" = na { namedAName = "Float", namedAValue = "gString2Num", namedAFunction = gString2Num }    
    | n == "Double" = na { namedAName = "Double", namedAValue = "gString2Num", namedAFunction = gString2Num }        
    | n == "Bool" = na { namedAName = "Bool", namedAValue = "gString2Bool", namedAFunction = gString2Bool } 
--    monads 
    | n == "Just" = na { namedAName = "Just", namedAValue = "bracketsOpen", namedAFunction = bracketsOpen } 
    | n == "(:)" = na { namedAName = "(:)", namedAValue = "bracketsOpen", namedAFunction = bracketsOpen } 
--    identify Enum type, and uses brackets by default 
    | t == EnumDT = na { namedAName = n, namedAValue = "brackets", namedAFunction = brackets } 
--    handle product types 
    | t == ProductDT = na { namedAName = n, namedAValue = "bracketsOpen", namedAFunction = bracketsOpen } 
--    handle bracket types 
    | t == CloseBracketDT = na { namedAName = show t, namedAValue = "bracketsClose", namedAFunction = bracketsClose } 
    | t == CloseListBracketDT = na { namedAName = show t, namedAValue = "bracketsClose", namedAFunction = bracketsClose }     
--    should not occur 
    | otherwise = na { namedAName = concat ["Error! type2Load? dTName = ", n, " : dTType = ", show t, " : dTConfields = ", concat dtcs]} 
    where 
        n = dTName dt 
        t = dTType dt 
        dtcs = dTConfields dt 
        na = dt2NamedA dt namedALoad 

--    modify the value for d2 to 40587 or 1970-01-01 or epochDay for product type ModifiedJulianDay
--    this function can be called by mapSnd :: ( ( a,a ) -> a ) -> [a] -> [a] 
fixDateLoad :: NamedA String String -> NamedA String String -> NamedA String String 
fixDateLoad  d1 d2 
    | namedAName d1 == "ModifiedJulianDay" = d2 { namedAValue = "gString2Day", namedAFunction = ( gString2Day  )  } 
    | otherwise = d2 

--    converts d/m/y into ModifiedJulianDay  
--    format assumed to be in "%-d-%b-%y" format 
--    eg 20-Sep-2015  
--    newtype Day = ModifiedJulianDay {toModifiedJulianDay :: Integer} deriving ( Eq,Ord
--    assumes that  has d/m/y format 
gString2Day :: String -> String  
gString2Day  s 
--    = " \"" ++ trim s ++ "\" " 
--    | trace ( "gString2Day: s = " ++ s ++ " : year = " ++ year ++ " : month = " ++ month ++ " : day = " ++ day  ) False = undefined 
--    if not valid, show the epoch date 
    | md == Nothing = brackets " ( 40587 )" 
--    some checks; what is error date? using 1970 1 1 as error date 
    | length dateParts /= 3 = brackets " ( 40587 )" 
--    check day range 
    | not ( elem ( head dateParts ) ( map show [1..31] ) ) = brackets " ( 40587 )" 
--    check month and year ranges  
--    otherwise, show the interpreted date 
    | otherwise = brackets (  show ( ( toModifiedJulianDay.fromJust ) md )  )
    where 
        trimS = trim s 
--        dateParts = splitOneOf "-/" trimS 
        dateParts = C.sepBy "-/" trimS 
--    this a safe head and last. 
        day = read (  head dateParts  ) :: Int 
        monthName = head ( tail dateParts ) 
        month = fromMaybe 0 ( M.lookup monthName month2Map ) 
        year = read (  last dateParts  ) :: Integer  
--    fromGregorianValid :: Integer -> Int -> Int -> Maybe Day ( Y M D ) 
        md = fromGregorianValid year month day 
        
--    uses out date format to convert ModifiedJulianDay to a Gregorian Date 
gString2GregDay :: String -> String 
gString2GregDay  s = undefined 

--    map months to numbers 
month2Map :: M.Map String Int 
month2Map = tuple2Map ( zip ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"] [1..12] )  

--    wrap strings into brackets for parsing 
gString2Num :: String -> String 
gString2Num s
    | trimS == [] = " ( 0 )"      
    | otherwise = brackets trimS
    where trimS = trim s 

--    assume that any string starting with T is True, else False 
gString2Bool :: String -> String 
gString2Bool s
    | trimS == [] = " ( False )" 
--    this is a safe head. 
    | head trimS == 'T' = " ( True )" 
    | otherwise = " ( False )" 
    where trimS = trim s 

gString2String :: String -> String  
gString2String s = brackets ( " ( \"" ++ trim s ++ "\" ) " ) 

--    f p16
--    this is best for initial parsing to discover correct dates 
--    input = "6-Oct-92" or "6/Oct/92"
--    %b months assumes short format 
--    fromGregorian 1970 1 1  
--    see Data.Time.Format 
string2DayEither :: String -> Either String Day  
string2DayEither s 
    | length dateParts /= 3 = Left ( "Error! string2DayEither? not enough date parts: " ++ trimS ) 
    | notElem day ( map show [1..31] ) = Left ( "Error! string2DayEither? day is not valid: " ++ trimS ) 
    | notElem month ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"] = Left ( "Error! string2DayEither? month is not valid: " ++ trimS ) 
    | not ( all isDigit year ) = Left ( "Error! string2DayEither? year is not valid: " ++ trimS )     
--    | otherwise = Right ( parseTimeOrError True defaultTimeLocale "%-d-%b-%y" trimS ) 
    | otherwise = Right ( fromGregorian ( read year :: Integer ) ( s2i month ) ( s2i day ) )  
    where 
        trimS = trim s 
--        dateParts = splitOneOf "-/" trimS 
        dateParts = C.sepBy "-/" trimS 
        day = head dateParts 
        month = head ( tail dateParts ) 
        year = last dateParts 
        s2i s = read s :: Int 
        
--    f p17        
--    if the date is valid, then show it, otherwise use epochUTCTime 
--    error cases should be the same as for string2DayEither 
--getDefault :: ( String -> b ) -> Either String b -> b 
string2DayDefault :: String -> Day  
string2DayDefault s 
    = getDefault ( \_ -> epochDay ) ( string2DayEither s ) 

-------------------------
--  header using DT 
--    uses available using defined types 

--    uses the defined types 
--    show field and product types 
--    always use the predefined default 
--    example: gheaderShowDOld bucketDefault = "Bucket,bucketKey,bucketMax,bucketFull,bucketi2NDKey,bucketDate,bucketTestType2"
gheaderShowDOld :: Data a => a -> String 
gheaderShowDOld a = ghdrShow ( ghD a ) 

--    show field and dates only only 
--    example: gheaderFieldD bucketDefault = "bucketKey,bucketMax,bucketFull,bucketi2NDKey,bucketDate,bucketTestType2"
gheaderFieldD :: Data a => a -> String 
gheaderFieldD a = ghdrField ( ghD a ) 
--    from an undefined type - this does not have accessor names! 
--    gheaderU :: ( Data a, Show a ) => a -> String 
--    gheaderU a = ghdrShow ( ghU a ) a 

--    common function used by defined and undefined types 
--    rebuild  with Constructors for the product types, and add  ) to end 
ghdrShow :: [NamedA ( Maybe String ) ( Maybe String )] -> String 
ghdrShow ns 
--    | trace ( "ghdrShow: ns = " ++ map show ns   ) False = undefined 
--    creates a function f [String] -> String  
    | otherwise = intercalate sc ( catMaybes ( map namedAValue ns ) ) 
    where sc = sepCharS 
--    where sc = ","     

--    common function used by defined and undefined types 
--    rebuild  with Constructors for the product types, and add  ) to end 
ghdrField :: [NamedA ( Maybe String ) ( Maybe String )] -> String 
ghdrField ns 
--    | trace ( "ghdrField: ns = " ++ map show ns   ) False = undefined 
--    creates a function f [String] -> String  
    | otherwise = intercalate sc ( catMaybes ( map namedAValue ( filter gIsFieldOrDate ns ) ) )  
    where sc = sepCharS 
--    where sc = ","     

--    initial call to traverse ADT AST to expose the header fields  
gh :: Data a => ( a -> [DT] ) -> a -> [NamedA ( Maybe String ) ( Maybe String )] 
gh f a 
    = mapSnd fixDateHeader ( map type2Header ( f a ) ) 
    
--    initial call to traverse ADT AST to expose the header fields   
--    fix the Day type gIsMaybeNode :: DTTree ( NamedA b c ) -> Bool 
ghTree :: Data a => ( a -> DTTree DT ) -> a -> DTTree ( NamedA ( Maybe String ) ( Maybe String ) ) 
ghTree f a 
--    | trace ( "ghTree: nt = " ++ show nt  ) False = undefined 
    | otherwise = branchReplace gIsListNode fixListHeader ( branchReplace gIsDayNode fixDayHeader nt ) 
    where nt = fmap type2Header ( f a ) 
    
--    applies a fix for Day type for header 
fixDayHeader :: DTTree ( NamedA ( Maybe String ) ( Maybe String ) ) -> DTTree ( NamedA ( Maybe String ) ( Maybe String ) ) 
fixDayHeader ( DTNode t sf ) 
--    ignore nothing nodes  
    | isNothing t = DTNode t sf 
--    toss away the forest  
    | ( namedAName.fromJust ) t == "ModifiedJulianDay" = DTNode t [] 
--    otherwise, do no harm      
    | otherwise = DTNode t sf 
    
--    applies a fix for List type for header 
fixListHeader :: DTTree ( NamedA ( Maybe String ) ( Maybe String ) ) -> DTTree ( NamedA ( Maybe String ) ( Maybe String ) ) 
fixListHeader ( DTNode t sf ) 
--    ignore nothing nodes  
    | isNothing t = DTNode t sf 
--    toss away the whole forest 
    | ( namedAName.fromJust ) t == "(:)" = DTNode t [] 
--    otherwise, do no harm  
    | otherwise = DTNode t sf 
    
--    listify the Tree 
ghTreeD :: Data a => a -> [NamedA ( Maybe String ) ( Maybe String )] 
ghTreeD a 
    = flattenDFS ( ghTree gADTD2Tree a ) 
    
--    New Tree based geader show 
gheaderShowD :: Data a => a -> String 
gheaderShowD a = ghdrShow ( ghTreeD a ) 
   
--    from a defined type 
ghD :: Data a => a -> [NamedA ( Maybe String ) ( Maybe String )]   
ghD a = gh gADTD2ListD a 
--    from an undefined type - this does not have accessor names! 
--    ghU :: Data a => a -> [NamedA ( Maybe String ) ( Maybe String )] 
--    ghU a = gh gADTU2ListU a 
    
--    simple default 
--    id function will force the b type as well 
namedAHeader = namedADefault { namedAValue = Nothing, namedAFunction = id } 

--    allocate a the type name and value for each type 
--    TRep defaults   
--    gdU ( undefined::Bucket ) = " ( Bucket  ( 0 )   ( SQL2 )   ( 0.0 )   ( False )   \" \"  (  ModifiedJulianDay  (  40587  )  )  ) " 
type2Header :: DT -> NamedA ( Maybe String ) ( Maybe String ) 
type2Header dt 
--    | trace ( "type2Header: dTName = " ++ n ++ " : dTType = " ++ show t ++ " : dTConfields = " ++ show dtcs  ) False = undefined 
    | n == "[Char]" = na2 
    | n == "Char" = na2 
    | n == "Int" = na2 
    | n == "Integer" = na2 
    | n == "Float" = na2 
    | n == "Double" = na2     
    | n == "Bool" = na2 
--    monads 
    | n == "Just" = na2 
    | n == "(:)" = na2     
--    identify Enum type, and take first element 
    | t == EnumDT = na2 
--    handle product types; if no accessors use the product type 
    | t == ProductDT = na { namedAName = n, namedAValue = Just ( if isNothing dta then n else fromJust dta ) }  
--    handle bracket types - always 0 
    | t == CloseBracketDT = na3 
    | t == CloseListBracketDT = na3 
--    should not occur 
    | otherwise = na { namedAName = concat ["Error! type2Header? dTName = ", n, " : dTType = ", show t, " : dTConfields = ", concat dtcs] }  
    where 
        n = dTName dt 
        t = dTType dt 
        dta = dTAccessor dt
        dtcs = dTConfields dt 
        na = dt2NamedA dt namedAHeader 
        na2 = na { namedAName = n, namedAValue = dta }         
        na3 = na { namedAName = show t } 
        
--    modify the value for d2 to 40587 or 1970-01-01 or epochDay for product type ModifiedJulianDay
--    this function can be called by mapSnd :: ( ( a,a ) -> a ) -> [a] -> [a] 
fixDateHeader :: NamedA ( Maybe String ) ( Maybe String ) -> NamedA ( Maybe String ) ( Maybe String ) -> NamedA ( Maybe String ) ( Maybe String ) 
fixDateHeader d1 d2 
    | namedAName d1 == "ModifiedJulianDay" = d2 { namedAValue = Nothing } 
    | otherwise = d2 

--------------------------------------------------
--    gheader 
--    shows initial product name followed by all accessors ( filter ( /= [] ) ( ghead1 a ) ) )
gheaderShowQ :: Data a => a -> String 
gheaderShowQ a 
--    | trace ( "gheaderShowQ: ss = " ++ ss  ) False = undefined 
    | otherwise = ss 
    where ss = ( showConstr.toConstr ) a ++ sepCharS ++ ( intercalate sepCharS ( ghead1 a ) )   

ghead1 :: Data a => a -> [String] 
ghead1 
    = gheadRecurse `ext1Q` gheadList `extQ` gheadDay 

--    recurses back so that it traverse the whole  ADT data type tree  
gheadRecurse :: Data a => a -> [String]  
gheadRecurse a
    = getConstrFields a ++ concat ( gmapQ ghead1 a ) 

--    gets accessor names 
getConstrFields :: Data a => a -> [String] 
getConstrFields a 
    | ( not.isAlgType ) t = [] 
    | dataTypeConstrs t == [] = [] 
    | otherwise = ( constrFields.head.dataTypeConstrs ) t  
    where 
        t = dataTypeOf a  

--    ignores lists in header 
gheadList :: Data a => [a] -> [String] 
gheadList _ = [] 
--    this version shows the all the headings, but it appears after the next tab. 
--    | length ls == 0 = [] 
--    | length ls2 == 0 = [] 
--    | otherwise = [ "[" ++ concat ( intersperse "," ls2 ) ++ "]" ]  
--    where ls2 = concatMap ghead1 ls 
    
--    ignores Day accessor 
gheadDay :: Day -> [String] 
gheadDay _ = [] 

----------------------------
--    gunload with error messages 
gunloadDEither :: Show a => [NamedA String String] -> a -> Either String String 
gunloadDEither  ns a 
--    test empty 
    | ws == [] = Left "Error! gunloadDEither? : no string to unload." 
--    test count  
--    | length ws /= gcountShowU  a = Left ( "Error: wrong number of fields: Expected = " ++ show ( gcountShowU  a ) ++ " : Actual = " ++ show ( length ws ) ++ " : Input = " ++ s ) 
--    test if the each string can be transformed to the correct type 
--    trust by verify - assume that the string is well formed 
--    | not ( gcheckX  a ws ) = Left ( "Error: at least one string fails the type check: " ++ gunloadTest ns a ) 
    | otherwise = Right ( gunloadD ns a ) 
    where ws = wordsTab ( show a ) 

--    common function used by defined and undefined types 
--    simply fold in the ws using the ii index to each field
--    rebuild  with Constructors for the product types, and add  ) to end 
gunloadD :: Show a => [NamedA String String] -> a -> String 
gunloadD ns a  
--    | trace ( "gunloadD: ns = " ++ map show ns ++ " : ws = " ++ concat ws  ) False = undefined 
--   ensure a safety so that the !! does not go wrong, need to subtract 1 to get index 
    | length ws /= ( maximum ( map namedAShowIndex ns ) + 1 ) = concat ["Error! gunloadD? length ws = ", show ( length ws ), " : maximum = ", show ( ( maximum ( map namedAShowIndex ns ) + 1 ) ) ] 
--    creates a function f [String] -> String 
    | otherwise = intercalate "," ( catMaybes ( map ( function2Show ws ) ns ) ) 
        where ws = wordsTab ( show a ) 
    
--    allocate a string argument to a function name 
function2Show :: [String] -> NamedA String String -> Maybe String 
function2Show xs na 
    | gIsField na = Just ( ( namedAFunction na ) ( xs !! ( namedAShowIndex na ) ) )
    | otherwise = Nothing 
        
--    testing function application  
--    shows function name and input string 
gunloadTest :: Show a => [NamedA String String] -> a -> String 
gunloadTest ns a 
--    | trace ( "gunloadTest: tycon = " ++ show ( ( dataTypeName.dataTypeOf ) a ) ++ " : datarep = " ++ show ( dataTypeRep a ) ) False = undefined 
--   ensure a safety so that the !! does not go wrong, need to subtract 1 to get index 
--    | length ws /= maximum ( map namedAShowIndex ns ) + 1 = concat ["Error! gunloadTest? length ws = ", show ( length ws ), " : maximum = ", show ( maximum ( map namedAShowIndex ns ) + 1 ) ] 
--    test for tabs in the strings ? 
    | otherwise = intercalate " " ( map ( name2Show ws ) ns ) 
    where ws = wordsTab ( show a ) 

--    enables the argument allocation to be transparent   
name2Show :: [String] -> NamedA String String -> String 
name2Show xs na 
    = ( if gIsProduct na then nf "" ++ namedAName na ++ " " else " "  ) ++ namedAValue na ++ ( if gIsField na then " (  xs !! " ++ show ii ++ "  ) = " ++ xs !! ii else " " ) ++ ( if gIsCloseBracket na then nf "" else " "  ) 
    where 
        ii = ( namedAShowIndex na ) 
        nf = namedAFunction na 

--    initial call to traverse ADT AST to unload the fields  
guld :: Data a => ( a -> [DT] ) -> a -> [NamedA String String] 
guld f a 
    = mapSnd fixDateUnload ( map type2Unload ( f a ) ) 

--    from an undefined type 
guldU :: Data a => a -> [NamedA String String]  
guldU a = guld gADTU2ListU a 
    
--    from a defined type 
guldD :: Data a => a -> [NamedA String String]   
guldD a = guld gADTD2ListD a 

--    pairs up elements of trees 
--zipTree :: DTTree a -> DTTree b -> DTTree ( a,b ) 
guldZipTree :: Data a => a -> DTTree ( NamedA String String ) -> DTTree ( NamedA String String ) -> DTTree ( ( NamedA String String ), ( NamedA String String ) ) 
guldZipTree = undefined 

--    fix the Day type gIsMaybeNode :: DTTree ( NamedA b c ) -> Bool 
guldValue :: Data a => ( a -> DTTree DT ) -> a -> DTTree ( NamedA String String ) 
guldValue f a 
--    | trace ( "ghTree: nt = " ++ show nt  ) False = undefined 
--    | otherwise = branchReplace gIsMaybeNode fixMaybeUnload ( branchReplace gIsListNode fixListUnload ( branchReplace gIsDayNode fixDayUnload nt ) ) 
    | otherwise = nt 
    where nt = fmap type2UnloadValue ( f a ) 

--    create a function using show to parse this ... 
--    a -> DTTree ( NamedA String String ) 
--    show schemaTestDefault
--    -> "( SchemaTest ( False ) ( Just ( 0 ) ) ( (:) \" \" ( [] ) ) ( (:) ( I2NDIn \" \" ( 0 ) ( ' ' ) ) ( [] ) ) )"
    
--    unload default 
namedAUnloadValue = namedADefault { namedAValue = "gulShow", namedAFunction = gulShow } 

--    initial allocation of unload functions based on base type 
type2UnloadValue :: DT -> NamedA String String  
type2UnloadValue dt 
--    | trace ( "type2UnloadValue: dTName = " ++ n ++ " : dTType = " ++ show t ++ " : dTConfields = " ++ show dtcs  ) False = undefined 
--    if empty string is default, this will be ignored.  
--    so a string with a space is needed 
    | n == "[Char]" = na2 { namedAValue = "[Char]"   } 
    | n == "Char" = na2 { namedAValue = "Char"   } 
    | n == "Int" = na2 { namedAValue = "Int"   } 
    | n == "Integer" = na2 { namedAValue = "Integer"   } 
    | n == "Float" = na2 { namedAValue = "Float"   } 
    | n == "Double" = na2 { namedAValue = "Double" }     
    | n == "Bool" = na2 { namedAValue = "Bool"   } 
--    monads 
    | n == "Just" = na2 { namedAValue = "Just"   } 
    | n == "(:)" = na2 { namedAValue = "(:)"   } 
--    identify Enum type, and take first element 
    | t == EnumDT = na3 
--    handle product types 
    | t == ProductDT = na3 
--    handle bracket types - always True 
    | t == CloseBracketDT = na3  
    | t == CloseListBracketDT = na3 
--    should not occur 
    | otherwise = na { namedAName = concat ["Error! type2UnloadValue? dTName = ", n, " : dTType = ", show t, " : dTConfields = ", concat dtcs], namedAValue = "" }      
    where 
        n = dTName dt 
        t = dTType dt 
        dtcs = dTConfields dt 
        na = dt2NamedA dt namedAUnloadValue 
        na2 = na { namedAName = n } 
        na3 = na { namedAName = show t } 

--    initial call to traverse ADT AST to expose the unload fields   
--    fix the Day type gIsMaybeNode :: DTTree ( NamedA b c ) -> Bool 
guldTree :: Data a => ( a -> DTTree DT ) -> a -> DTTree ( NamedA String String ) 
guldTree f a 
--    | trace ( "ghTree: nt = " ++ show nt  ) False = undefined 
    | otherwise = branchReplace gIsMaybeNode fixMaybeUnload ( branchReplace gIsListNode fixListUnload ( branchReplace gIsDayNode fixDayUnload nt ) ) 
--    | otherwise = nt 
    where nt = fmap type2Unload ( f a ) 
    
--    applies a fix for Day type for unload 
fixDayUnload :: DTTree ( NamedA String String ) -> DTTree ( NamedA String String ) 
fixDayUnload ( DTNode t sf ) 
--    ignore nothing nodes  
    | isNothing t = DTNode t sf 
--    ignore empty forests 
    | length sf == 0 = DTNode t sf     
--    insert the gulShowDate function 
    | ( namedAName.fromJust ) t == "ModifiedJulianDay" = DTNode t [DTNode ( Just ( ( ( fromJust.dTRootLabel.head ) sf ) { namedAValue = "gulShowDate", namedAFunction = gulShowDate } ) ) []]     
--    otherwise, do no harm  
    | otherwise = DTNode t sf 

--    applies a fix for Maybe type for unload  
--    unclear if this is needed? 
fixMaybeUnload :: DTTree ( NamedA String String ) -> DTTree ( NamedA String String ) 
fixMaybeUnload ( DTNode t sf ) 
--    ignore nothing nodes  
    | isNothing t = DTNode t sf 
--    toss away the whole forest 
    | ( namedAName.fromJust ) t == "Just" = DTNode t [] 
--    otherwise, do no harm  
    | otherwise = DTNode t sf 
    
--    applies a fix for List type for unload 
fixListUnload :: DTTree ( NamedA String String ) -> DTTree ( NamedA String String ) 
fixListUnload ( DTNode t sf ) 
--    ignore nothing nodes  
    | isNothing t = DTNode t sf 
--    toss away the whole forest 
    | ( namedAName.fromJust ) t == "(:)" = DTNode t [] 
--    otherwise, do no harm  
    | otherwise = DTNode t sf 
 
--    listify the Tree 
guldTreeD :: Data a => a -> [NamedA String String] 
guldTreeD a 
    = flattenDFS ( guldTree gADTD2Tree a ) 
    
--    unload default 
namedAUnload = namedADefault { namedAValue = "gulShow", namedAFunction = gulShow } 

--    initial allocation of unload functions based on base type 
type2Unload :: DT -> NamedA String String  
type2Unload  dt 
--    | trace ( "type2Unload: dTName = " ++ n ++ " : dTType = " ++ show t ++ " : dTConfields = " ++ show dtcs  ) False = undefined 
--    if empty string is default, this will be ignored.  
--    so a string with a space is needed 
    | n == "[Char]" = na { namedAName = "[Char]", namedAValue = "gulShowString", namedAFunction = gulShowString } 
    | n == "Char" = na { namedAName = "Char", namedAValue = "gulShowString", namedAFunction = gulShowString }  
    | n == "Int" = na { namedAName = "Int", namedAValue = "gulShowNum", namedAFunction = gulShowNum }   
    | n == "Integer" = na { namedAName = "Integer", namedAValue = "gulShowNum", namedAFunction = gulShowNum }   
    | n == "Float" = na { namedAName = "Float", namedAValue = "gulShowNum", namedAFunction = gulShowNum }  
    | n == "Double" = na { namedAName = "Double", namedAValue = "gulShowNum", namedAFunction = gulShowNum }      
    | n == "Bool" = na { namedAName = "Bool" } 
--    monads 
    | n == "Just" = na { namedAName = "Just", namedAValue = "gulShowMaybe", namedAFunction = gulShowMaybe } 
    | n == "(:)" = na { namedAName = "(:)", namedAValue = "gulShowList", namedAFunction = gulShowList } 
--    identify Enum type, and take first element 
    | t == EnumDT = na { namedAName = n, namedAValue = "gulShowEnumType", namedAFunction = gulShowEnumType }  
--    handle product types 
    | t == ProductDT = na { namedAName = n } 
--    handle bracket types - always True 
    | t == CloseBracketDT = na { namedAName = show t } 
    | t == CloseListBracketDT = na { namedAName = show t, namedAValue = "gulShowCloseList", namedAFunction = gulShowCloseList }     
--    should not occur 
    | otherwise = na { namedAName = concat ["Error! type2Unload? dTName = ", n, " : dTType = ", show t, " : dTConfields = ", concat dtcs], namedAValue = "" }      
    where 
        n = dTName dt 
        t = dTType dt 
        dtcs = dTConfields dt 
        na = dt2NamedA dt namedAUnload 

--    modify the value for d2 to 40587 or 1970-01-01 or epochDay for product type ModifiedJulianDay
--    this function can be called by mapSnd :: ( ( a,a ) -> a ) -> [a] -> [a] 
fixDateUnload :: NamedA String String -> NamedA String String -> NamedA String String 
fixDateUnload  d1 d2 
    | namedAName d1 == "ModifiedJulianDay" = d2 { namedAValue = "gulShowDate", namedAFunction = ( gulShowDate  )  } 
    | otherwise = d2         
        
--    convert ModifiedJulianDay n to d/m/y format 
gulShowDate :: String -> String  
gulShowDate  s = showGregorian ( ModifiedJulianDay ( ( read s )::Integer ) ) 

gulShowDay :: String -> String  
gulShowDay s = trim s 

--    show basic types 
gulShow :: String -> String  
gulShow s = trim s 

gulShowEnumType :: String -> String  
gulShowEnumType s = trim s 

gulShowConstr :: String -> String  
gulShowConstr s = trim s 

gulShowNum :: String -> String 
gulShowNum s
    | trimS == [] = "0"      
    | otherwise = trimS 
    where trimS = trim s 

gulShowMaybe :: String -> String  
gulShowMaybe s = "Just " ++ trim s  

gulShowList :: String -> String  
gulShowList s = "[ " ++ trim s  

gulShowCloseList :: String -> String  
gulShowCloseList s = trim s ++ " ]" 

gulShowString :: String -> String  
gulShowString s = "\"" ++ trim s ++ "\"" 

-------------------------------------
--    create a show using gmapQ to serialise a String 

--    shows initial product name followed by all accessors 
--    usage example 
--    instance Show ColumnIn where show = gshowQ  

gshowQ :: Data a => a -> String 
gshowQ a
--    | trace ( "gshowQ: ss = " ++ ss  ) False = undefined 
    | otherwise = ss 
    where ss = intercalate sepCharS ( gshow2 a ) 

gshow2 :: Data a => a -> [String] 
gshow2 
    = gshowRecurse2 `ext1Q` gshowList2 `ext1Q` gshowMaybe2 `extQ` gshowString2 `extQ` gshowChar2 `extQ` gshowInt2 `extQ` gshowBool2XLS `extQ` gshowFloat2 `extQ` gshowDay2 `extQ` gshowInteger2 `extQ` gshowDouble2 `extQ`  gshowUTCTime2 
    
gshowRecurse2 :: Data a => a -> [String] 
gshowRecurse2 a
    = [( showConstr.toConstr ) a] ++ concat ( gmapQ gshow2 a ) 
    
--    list monad 
gshowList2 :: Data a => [a] -> [String]  
gshowList2 ls 
    = [ "[" ++ concat ( intersperse "," ( concatMap gshow2 ls ) ) ++ "]" ] 
    
--    maybe monad 
gshowMaybe2 :: Data a => Maybe a -> [String]  
gshowMaybe2 ma
    | isNothing ma = [ "Nothing" ] 
    | otherwise = gshow2 ( fromJust ma ) 
    
gshowString2 :: String -> [String] 
gshowString2 s = [s] 

gshowChar2 :: Char -> [String] 
gshowChar2 c = [show c]

gshowBool2 :: Bool -> [String] 
gshowBool2 b = [show b] 

--     convert True to 1 and False to 0 for easy use in Excel 
gshowBool2XLS :: Bool -> [String] 
gshowBool2XLS b = [if b then "1" else "0"] 

gshowInt2 :: Int -> [String] 
gshowInt2 i = [show i] 

gshowInteger2 :: Integer -> [String] 
gshowInteger2 i = [show i] 

gshowFloat2 :: Float -> [String] 
gshowFloat2 n = [show n]

gshowDouble2 :: Double -> [String] 
gshowDouble2 n = [show n]

gshowDay2 :: Day -> [String] 
gshowDay2 d = [showGregorian d] 

gshowUTCTime2 :: UTCTime -> [String] 
gshowUTCTime2 u = [take 10 ( show u )] 

--    mutual recursion for ADT tree traversal 
--    use extQ like an applicative 
--    extQ :: ( Typeable a, Typeable b ) => ( a -> q ) -> ( b -> q ) -> a -> q
--    replaces $( thBuildInstanceShowProdADT ''I2ND ) 
gshow1 :: Data a => a -> String 
gshow1 
    = gshowRecurse `ext1Q` gshowList `ext1Q` gshowMaybe `extQ` gshowDay `extQ` gshowString `extQ` gshowChar `extQ` gshowInt `extQ` gshowFloat `extQ` gshowInteger `extQ` gshowBool `extQ` gshowDouble

--    recurses back so that it traverse the whole  ADT data type tree  
gshowRecurse :: Data a => a -> String 
gshowRecurse a
    = ( showConstr.toConstr ) a ++ sepCharS ++ intercalate sepCharS ( gmapQ gshow1 a ) 
    
--    list monad 
gshowList :: Data a => [a] -> String 
gshowList ls 
    = "[" ++ concat ( intersperse "," ( map gshow1 ls ) ) ++ "]" 
    
--    maybe monad 
gshowMaybe :: Data a => Maybe a -> String 
gshowMaybe ma
    | isNothing ma = "Nothing" 
    | otherwise = gshow1 ( fromJust ma ) 

--    special cases for String and Bool 
gshowString :: String -> String
gshowString s = s 

gshowChar :: Char -> String
gshowChar = show 

gshowBool :: Bool -> String
gshowBool = show  

gshowInt :: Int -> String
gshowInt = show 

gshowInteger :: Integer -> String
gshowInteger = show  

gshowFloat :: Float -> String
gshowFloat = show  

gshowDouble :: Double -> String
gshowDouble = show  

gshowDay :: Day -> String
gshowDay = showGregorian 

--   unused 
--     convert True to 1 and False to 0 for easy use in Excel 
gshowBoolXLS :: Bool -> String
gshowBoolXLS b = if b then "1" else "0" 

--    show for xls with 0/1 subbed for True/False 
gshowXLS :: Data a => a -> String 
gshowXLS 
    = gshow1 
    

--    from an undefined type 
gcheckU :: Data a => a -> [String] -> Bool 
gcheckU a xs 
--    = gcheck2Bool ( gckU  a ) xs 
    = gcheck2Bool2 a gcheck1U xs 
    
--    from a defined type 
gcheckD :: Data a => a -> [String] -> Bool 
gcheckD a xs 
--    = gcheck2Bool ( gckD  a ) xs 
    = gcheck2Bool2 a gcheck1D xs 
    
--    from an undefined type     
gcheck1U :: Data a => a -> [( String, ( String -> Bool ) )]
gcheck1U a 
--    | trace ( "gcheck1U: ss = " ++ intercalate sepCharS ( map fst ss )  ) False = undefined     
    | otherwise = ss 
    where ss = map ( \na -> ( namedAName na, namedAFunction na ) ) ( gck gADTU2ListU a ) 

--    from a defined type 
gcheck1D :: Data a => a -> [( String, ( String -> Bool ) )]
gcheck1D a 
--    | trace ( "gcheck1D: ss = " ++ intercalate sepCharS ( map fst ss )  ) False = undefined     
    | otherwise = ss 
    where ss = map ( \na -> ( namedAName na, namedAFunction na ) ) ( gck gADTD2ListD a )

--    common function used by defined and undefined types 
--    simply fold in the xs using the ii index to each field
--    rebuild  with Constructors for the product types, and add  ) to end 
gcheck2Bool :: [NamedA String Bool] -> [String] -> Bool 
gcheck2Bool ns xs 
--    | trace ( "gcheck2Bool: length xs "++ show ( length xs ) ++ " : max namedAFieldIndex = " ++ show ( maximum ( map namedAFieldIndex ns ) ) ++ " : ns = " ++ concatMap show ns ++ " : xs = " ++ concat xs  ) False = undefined 
--    | trace ( "gcheck2Bool: length xs "++ show ( length xs ) ++ " : max namedAFieldIndex = " ++ show ( maximum ( map namedAFieldIndex ns ) ) ++ " : xs = " ++ concat xs  ) False = undefined 
--    ignore empty lists 
    | xs == [] = False 
--    use count? 
--   ensure a safety so that the !! does not go wrong, need to subtract 1 to get index 
    | length xs /= maximum ( map namedAFieldIndex ns ) = False 
--    creates a function f [String] -> Bool  
    | otherwise = and ( catMaybes ( map ( name2FunctionBool xs ) ns ) )
    
--    allocate a string argument to a function name 
name2FunctionBool :: [String] -> NamedA String Bool -> Maybe Bool  
name2FunctionBool xs na 
--    | trace ( "name2FunctionBool: f = " ++ namedAValue na ++ " : x = " ++ x ++ " : na = " ++ show na  ) False = undefined 
--    ignore empty lists 
    | length xs == 0 = Nothing  
--    ignore zero index 
    | ind <= 0 = Nothing 
--    check if list is long enough 
    | length xs < ( ind - 1 ) = Nothing 
--    match function to string value 
    | gIsField na = Just ( f x )  
    | otherwise = Nothing 
    where 
        ind = namedAFieldIndex na 
        f = namedAFunction na 
--        x = xs !! ( ind - 1 ) 
        x = xs !! ind 
        
--    testing function application  
--    shows function name and input string 
gcheckTest3 :: [NamedA String Bool] -> [String] -> String 
gcheckTest3 ns xs 
--    | trace ( "gcheckTest3: tycon = " ++ show ( ( dataTypeName.dataTypeOf ) a ) ++ " : datarep = " ++ show ( dataTypeRep a ) ) False = undefined 
--   ensure a safety so that the !! does not go wrong, need to subtract 1 to get index 
    | length xs /= maximum ( map namedAFieldIndex ns ) = concat ["Error! gcheckTest3? length xs = ", show ( length xs ), " : maximum = ", show ( maximum ( map namedAFieldIndex ns )  ) ] 
--    | otherwise = intercalate ' ' ( map ( \( g,s ) -> " : " ++ g ++ " " ++ s  ) ( zip fns cxs ) ) 
    | otherwise = intercalate " " ( map ( name2FieldBool xs ) ns ) 
    
--    enables the argument allocation to be transparent   
name2FieldBool :: [String] -> NamedA String Bool -> String 
name2FieldBool xs na 
    = ( if gIsProduct na then namedAName na else ""  ) ++ " " ++ namedAValue na ++ ( if gIsField na then " (  xs !! " ++ show ii ++ "  ) = " ++ xs !! ii else " " ) ++ ( if gIsCloseBracket na then namedAName na else ""  ) ++ " "
    where ii = ( namedAFieldIndex na ) - 1 
    
--    initial call to traverse ADT AST to count the fields  
--    provides a way to slot in different ADT 2 List functions
--    filter out all brackets and ModifiedJulianDay 
gck :: Data a => ( a -> [DT] ) -> a -> [NamedA String Bool]   
gck f a 
    = filter ( not.( \n -> gIsBracket n || ( namedAName n == "ModifiedJulianDay" ) ) ) ( mapSnd fixDayCheck ( map type2Check ( f a ) ) )
    
--    from an undefined type 
gckU :: Data a => a -> [NamedA String Bool] 
gckU  a = gck gADTU2ListU a 
    
--    from a defined type 
gckD :: Data a => a -> [NamedA String Bool]   
gckD  a = gck gADTD2ListD a 
    
--    check default 
namedACheck = namedADefault { namedAValue = "gcheckTrue", namedAFunction = gcheckTrue } 

--    TRep defaults   
type2Check :: DT -> NamedA String Bool 
type2Check  dt 
--    | trace ( "type2Check: dTName = " ++ n ++ " : dTType = " ++ show t ++ " : dTConfields = " ++ show dtcs  ) False = undefined 
--    if empty string is default, this will be ignored.  
--    so a string with a space is needed 
    | n == "[Char]" = na { namedAName = "[Char]" }  
    | n == "Char" = na { namedAName = "Char", namedAValue = "gcheckChar", namedAFunction = gcheckChar }  
    | n == "Int" = na { namedAName = "Int", namedAValue = "gcheckInt", namedAFunction = gcheckInt }    
    | n == "Integer" = na { namedAName = "Integer", namedAValue = "gcheckInt", namedAFunction = gcheckInt }    
    | n == "Float" = na { namedAName = "Float", namedAValue = "gcheckFloat", namedAFunction = gcheckFloat }  
    | n == "Double" = na { namedAName = "Double", namedAValue = "gcheckFloat", namedAFunction = gcheckFloat }      
    | n == "Bool" = na { namedAName = "Bool", namedAValue = "gcheckBool", namedAFunction = gcheckBool }  
--    ignore monads - always True 
    | n == "Just" = na { namedAName = "Just" }  
    | n == "(:)" = na { namedAName = "(:)" }      
--    use the Enum type, and check if the s is an element in this enum type  
--    | t == EnumDT = na { namedAName = n, namedAValue = "gcheckEnumType2 " ++ n, namedAFunction = ( gcheckEnumType2 n ) }    
    | t == EnumDT = na { namedAName = n, namedAValue = "gcheckEnumType " ++ n, namedAFunction = ( gcheckEnumType dtcs ) } 
--    handle product types 
    | t == ProductDT = na { namedAName = n }   
--    handle bracket types - always True 
    | t == CloseBracketDT = na { namedAName = show t } 
    | t == CloseListBracketDT = na { namedAName = show t }     
--    should not occur 
--    | otherwise = na { namedAName = "otherwise" }  
    | otherwise = na { namedAName = concat ["Error! type2Check? dTName = ", n, " : dTType = ", show t, " : dTConfields = ", concat dtcs], namedAValue = "" }      
    where 
        n = dTName dt 
        t = dTType dt 
        dtcs = dTConfields dt 
--    namedAConfields 
        na = dt2NamedA dt namedACheck 
        
--    modify the value for d2 to 40587 or 1970-01-01 or epochDay for product type ModifiedJulianDay
--    this function can be called by mapSnd :: ( ( a,a ) -> a ) -> [a] -> [a] 
fixDayCheck :: NamedA String Bool -> NamedA String Bool -> NamedA String Bool 
fixDayCheck  d1 d2 
    | namedAName d1 == "ModifiedJulianDay" = d2 { namedAName = "Day", namedAValue = "gcheckDay", namedAFunction = gcheckDay } 
    | otherwise = d2  
        
--    checks if string is unambiguous is in confields 
gcheckEnumType :: [String] -> String -> Bool  
gcheckEnumType confields s 
--    | trace ( "gcheckEnumType: s = " ++ s  ) False = undefined 
    | confields == [] = False
--    this is a safe head. see above. 
    | elem trimS confields = True 
    | otherwise = False 
    where trimS = trim s 
        
--    !!!NOTE; Dead end here; this pattern is not used, as again there is a need to depend on pre-defined sum types
--    
--    all enum types already defined as string lists in allEnumLU 
--    a is the name of the type  
--    lookup :: Eq a => a -> [( a, b )] -> Maybe b 
--    fromMaybe :: a -> Maybe a -> a
gcheckEnumType2 :: String -> String -> Bool 
gcheckEnumType2 a s  
--    | trace ( "gcheckEnumType2: luList = " ++ intercalate "," luList ++ " : a = " ++ a ++ " : s = " ++ s ) False = undefined 
--    | luList == [] = False 
    | length luList == 0 = False 
    | elem s luList = True 
    | otherwise = False 
--    where luList = fromMaybe [] ( lookup a allEnumLU ) 
    where luList = [] 
    
--    as new Enums are added to EnumType, add a new entry here ... 
--      SourceType    FileType 
enumListCommon = [ makeEnumLU ( undefined::FileType ), makeEnumLU ( undefined::SourceType ) ] 

--    this is referred to directly in Enum validation. 
--    it cannot be passed in a gparm, as this gets lost in parm calls. 
allEnumLU :: [( String, [String] )] 
allEnumLU = map enumLU2KV enumListCommon 
    
-----------------------------------
--    !!! NOTE: Cannot really use this pattern as the sum types need to be defined 
--    and the checking functions like gcheckFileType2 need to be manually defined
--    instead the dTConfields in DT are used to check for sum type value. 
--    
--    applies the correct check function to each successive list element 
--    extracts the check function from the ( type, function ) tuple list 
--    zips each corresponding input string to its check function 
--    assumes that the type needs to be added to the list 
gcheckQ :: Data a => a -> [String] -> Bool 
gcheckQ a xs 
--    = and ( map ( \( f,x ) -> f x ) ( zip ( map snd ( gcheck2F a ) ) ( [getStaticType a] ++ xs ) ) ) 
    = gcheck2Bool2 a gcheck2F xs 

--    gcheck wrapper      
gcheck2Bool2 :: Data a => a -> ( a -> [( String, ( String -> Bool ) )] ) -> [String] -> Bool 
gcheck2Bool2 a g xs 
    = and ( map ( \( f,x ) -> f x ) ( zip ( map snd ( g a ) ) ( [getStaticType a] ++ xs ) ) ) 

--    gets final list of type names and check functions tuples 
gcheck2F :: Data a => a -> [( String, ( String -> Bool ) )]  
gcheck2F a 
--    | trace ( "gcheck2F: ss = " ++ intercalate sepCharS ( map fst ss )  ) False = undefined 
    | otherwise = ss 
    where ss = gcheck2 a 
       
--    default, for ADTs, just shows the type, with always True 
gcheckRecurse2 :: Data a => a -> [( String, ( String -> Bool ) )]  
gcheckRecurse2 a 
--    | trace ( "gcheckRecurse2: st = " ++ st  ) False = undefined 
    | otherwise = [( getStaticType a, gcheckTrue )] ++ concat ( gmapQ gcheck2 a ) 
    
--    recursive call to get list of type names and check functions tuples 
gcheck2 :: Data a => a -> [( String, ( String -> Bool ) )]  
gcheck2 a 
--    | trace ( "gcheck2: ss = " ++ intercalate sepCharS ( map fst ss )  ) False = undefined 
    | otherwise = ss 
    where ss = ( gcheckRecurse2 `extQ` gcheckString2 `extQ` gcheckChar2 `extQ` gcheckInt2 `extQ` gcheckBool2 `extQ` gcheckFloat2 `extQ` gcheckDouble2 `extQ` gcheckDay2 `extQ` gcheckInteger2 `extQ` gcheckFileType2 `extQ` gcheckSourceType2   ) a

--    add in enums here 
gcheckFileType2 :: FileType -> [( String, ( String -> Bool ) )]  
gcheckFileType2 _ =  [( "FileType", ( gcheckEnumTypeU ( undefined::FileType ) ) )] 

gcheckSourceType2 :: SourceType -> [( String, ( String -> Bool ) )]  
gcheckSourceType2 _ =  [( "SourceType", ( gcheckEnumTypeU ( undefined::SourceType ) ) )] 

    
-------------------------
--    applies each string to respective function, applies them, and then folds the result 


--    checks if string is in "%-d-%b-%y" format 
--    eg 20-Sep-2015  
--    add fromGregorianValid :: Integer -> Int -> Int -> Maybe Day 
--    map months to numbers 
gcheckDay :: String -> Bool  
gcheckDay  s 
--    | trace ( "gcheckDay: s = " ++ s ++ " : year = " ++ year ++ " : month = " ++ month ++ " : day = " ++ day  ) False = undefined 
    | length dateParts /= 3 = False 
    | notElem day ( map show [1..31] ) = False
--    test for upper case as well? 
    | notElem month ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"] = False 
    | not ( all isDigit year ) = False  
    | otherwise = True 
    where 
        trimS = trim s 
--        dateParts = splitOneOf "-/" trimS 
        dateParts = C.sepBy "-/" trimS 
--    these are safe heads. see above. 
        day = head dateParts
        month = head ( tail dateParts ) 
        year = last dateParts 

--    checks if string is unambiguous - Just first Letter  
--    f t F T all acceptable 
gcheckBool :: String -> Bool  
gcheckBool s
--    | trace ( "gcheckBool: s = " ++ s  ) False = undefined 
    | trimS == [] = False
--    this is a safe head. see above. 
    | elem ( toUpper ( head trimS ) ) ['F','T'] = True 
    | otherwise = False 
    where trimS = trim s 
    
--    checks if string is a single char 
gcheckChar :: String -> Bool  
gcheckChar s
--    | trace ( "gcheckChar: s = " ++ s  ) False = undefined 
    | trimS == [] = False
    | length trimS == 1 = True 
    | otherwise = False 
    where trimS = trim s 

--    checks for neg numbers as well 
gcheckInt :: String -> Bool 
gcheckInt s 
--    | trace ( "gcheckInt: s = " ++ s  ) False = undefined 
    | trimS == [] = False 
--    first char can be digit or minus sign only 
    | ( ( not.isDigit ) headChar ) && ( headChar /= '-' ) = False  
--    checks for singleton minus, with no digits 
    | ( headChar == '-' ) && length ( tail trimS ) == 0 = False      
    | not ( all isDigit ( tail trimS ) ) = False 
    | otherwise = True 
        where 
        trimS = trim s 
--    this is a safe head. 
        headChar = head trimS 
        
--    checks for neg numbers 
--    E? 
--    ?! discard plus sign 
--    good case study for Quickcheck 
gcheckFloat :: String -> Bool 
gcheckFloat s 
--    | trace ( "gcheckFloat: s = " ++ s  ) False = undefined 
    | trimS == [] = False 
--    first char can be digit or minus sign only 
    | ( ( not.isFloatDigit ) headChar ) && not ( isMinus headChar ) = False  
--    checks for singleton minus, with no digits 
    | ( headChar == '-' ) && length ( tail trimS ) == 0 = False 
--    checks for only valid chars 
    | not ( all isFloatDigit ( tail trimS ) ) = False 
--    ensure either 0 or 1 decimal points  
    | length ( filter isDecPt trimS ) > 1 = False 
--    if no e, then only one - 
    | ( not hasExp ) && length ( filter isMinus trimS ) > 1 = False 
--    
    | otherwise = True 
        where 
        trimS = trim s 
--    this is a safe head. 
        headChar = head trimS 
        isMinus = ( == '-' ) 
        isPlus = ( == '+' ) 
        isDecPt = ( == '.' ) 
        hasExp = elem 'e' ( map toLower trimS ) 
--    allow signs, digits, plus e for exponent 
        isFloatDigit c = isDigit c || isDecPt c || ( ( toLower c ) == 'e' ) || isMinus c 

--    always True 
gcheckTrue :: String -> Bool  
gcheckTrue _ = True 

--    always False  
gcheckFalse :: String -> Bool  
gcheckFalse _ = False 

-------------------
--    helpers for gcheck 

gcheckString2 :: String -> [( String, ( String -> Bool ) )]  
gcheckString2 _ = [( "[Char]", gcheckTrue )] 

gcheckChar2 :: Char -> [( String, ( String -> Bool ) )]  
gcheckChar2 _ = [( "Char", gcheckChar )] 

gcheckBool2 :: Bool -> [( String, ( String -> Bool ) )]  
gcheckBool2 _ = [( "Bool", gcheckBool )] 

gcheckInt2 :: Int -> [( String, ( String -> Bool ) )]  
gcheckInt2 _ = [( "Int", gcheckInt )] 

gcheckInteger2 :: Integer -> [( String, ( String -> Bool ) )]  
gcheckInteger2 _ = [( "Integer", gcheckInt )] 

gcheckFloat2 :: Float -> [( String, ( String -> Bool ) )]  
gcheckFloat2 _ =  [( "Float", gcheckFloat )] 

gcheckDouble2 :: Double -> [( String, ( String -> Bool ) )]  
gcheckDouble2 _ =  [( "Double", gcheckFloat )] 

gcheckDay2 :: Day -> [( String, ( String -> Bool ) )]  
gcheckDay2 _ =  [( "Day", gcheckDay )] 


-------------------------------------
--    gread 
--    Based on the standard gread from import Data.Generics.Text 

--    generic read 
--    uses an undefined 'a' type to generate an 'a' value 
--    dt = ( undefined::( dataTypeOf a ) ) 
--    type of g::[( ( dataTypeOf a ), String )] 

--    read is more forgiving than gread! 
--    So, a type can be read using read that will fail using gread! 
--    Watch out for extra brackets as this causes gread to fail, but these are ignored by read. 

greadF :: Data a => a -> String -> a 
greadF a s 
--    | trace ( "greadF: s = " ++ s ++ " : length g = " ++ show ( length g ) ) False = undefined 
--    note that a does not need to be a defined value - only the type is read 
--    if cannot parse type, then use default 
--    totally UNSAFE head. Will cause issues if parsing incorrect! 
    | length g == 0 = ( fst.head.gread.gd2S.gdU ) a 
--    otherwise, turn the string into a Type. Magic! 
    | otherwise = ( fst.head ) g  
    where g = gread s 
    
--    readEither :: Read a => String -> Either String a 
greadEither :: Data a => a -> String -> Either String a  
greadEither a s 
    | length g == 0 = Left "Error!: greadEither? returns nothing" 
--    this is a safe head. 
    | otherwise = Right ( ( fst.head ) g ) 
    where g = gread s     
        
--    add in brackets for parsing 
--    converts a string into the Enum Type 
gstring2EnumType :: Data a => a -> String -> Either String a  
gstring2EnumType a s 
--    the call to gcheckEnumTypeD assumes a value, so undefined fails 
--    gcheckEnumTypeU enables the test at the type level only 
    | not ( gcheckEnumTypeU a trimS ) = Left ( "Error! gstring2EnumType? string is not in this Enum List: " ++ trimS  ) 
--    ++ " of type: " ++ ( dataTypeName.dataTypeOf ) a ) 
--    brackets are needed by the generic read  
    | otherwise = Right ( greadF a ( brackets trimS ) ) 
    where trimS = trim s 

--    readMaybe :: Read a => String -> Maybe a 
greadMaybe :: Data a => a -> String -> Maybe a  
greadMaybe a s 
    | length g == 0 = Nothing 
--    this is a safe head. 
    | otherwise = Just ( ( fst.head ) g ) 
    where g = gread s 
  
-------------------------------------
--    properties 

--    test that the underlying DTTree are identical 
--    that is, DTTree DT == DTTree DT 
prop_gADTD2Tree_eq_gADTU2Tree :: Data a => a -> Bool
prop_gADTD2Tree_eq_gADTU2Tree a 
--    instead pair up in a tree the defined and undefined lists, 
--    and then apply a custom equality function that ignores confields and accessor 
    = and ( map ( \( d,u ) -> dTEq d u ) ( flattenDFS ( zipTree ( gADTD2Tree ( gdefaultU a ) ) ( gADTU2Tree a ) ) ) )  

--    test that the list serializations are identical 
--    that is, [DT] == [DT]  
prop_gADTD2List_eq_gADTU2List :: Data a => a -> Bool
prop_gADTD2List_eq_gADTU2List a 
--    does not work as confields and accessor are not in gADTU2ListU 
--    = gADTD2ListD ( gdefaultU a ) == gADTU2ListU a 
--    does not work as the confields and accessor are still not excluded 
--    = sd ( gADTD2ListD ( gdefaultU a ) ) == sd ( gADTU2ListU a )   
--    where sd ds = concatMap ( \d -> dTName d ++ show ( dTType d ) ) ds  
--    instead pair up the defined and undefined lists, 
--    and then apply a custom equality function that ignores confields and accessor 
    = and ( map ( \( d,u ) -> dTEq d u ) ( zip ( gADTD2ListD ( gdefaultU a ) ) ( gADTU2ListU a ) ) ) 
    
--    ( gADTD2Tree ( gdefaultU a ) ) ( gADTU2Tree a ) ) ) )   ( gADTD2ListD ( gdefaultU a ) ) ( gADTU2ListU a ) ) ) 
--    putStrLn $ "show ( gADTD2ListD ( gdefaultU a ) ) = " ++ show ( gADTD2ListD ( gdefaultU ( undefined::DBCommonFile )  ) )      
--    putStrLn $ "show ( gADTU2ListU a ) = " ++ show ( gADTU2ListU ( undefined::DBCommonFile )  )
--    putStrLn $ "showDT ( gADTD2ListD ( gdefaultU a ) ) = " ++ sepCharS ++ intercalate sepCharS ( map showDT ( gADTD2ListD ( gdefaultU ( undefined::DBCommonFile ) ) ) ) 
--    putStrLn $ "showDT ( gADTU2ListU a ) = " ++ sepCharS ++ intercalate sepCharS ( map showDT ( gADTU2ListU ( undefined::DBCommonFile ) ) ) 

--    these properties all test that the boilerplate ( BP ) types 
--    are identical when generated from defined and undefined types 
--    test that the LOAD BP type NamedA lists are identical 
--    that is, [NamedA b c] == [NamedA b c] 
--    instance Eq b => Eq ( NamedA b c ) where 
prop_gldD_eq_gldU :: Data a => a -> Bool 
prop_gldD_eq_gldU a = and ( map tupleEq ( zip ( gldD ( gdefaultU a ) ) ( gldU a ) ) )  

--    putStrLn $ "showNamedA ( gldD ( gdefaultU a ) ) = " ++ sepCharS ++ intercalate sepCharS ( map showNamedA ( gldD ( gdefaultU ( undefined::DBCommonFile ) ) ) ) 
--    putStrLn $ "showNamedA ( gldU a ) = " ++ sepCharS ++ intercalate sepCharS ( map showNamedA ( gldU ( undefined::DBCommonFile ) ) ) 

--    test that the UNLOAD BP type NamedA lists are identical 
prop_guldD_eq_guldU :: Data a => a -> Bool 
prop_guldD_eq_guldU a = and ( map tupleEq ( zip ( guldD ( gdefaultU a ) ) ( guldU a ) ) )  

---------------------------------------

--    equality of gmapQ versus gunfold functions 
--    example 
--   putStrLn $ "prop_gelems_eq_gelemsU ( undefined::Bucket ) = " ++ show ( prop_gelems_eq_gelemsU ( undefined::Bucket )  ) 
prop_gelems_eq_gelemsU :: Data a => a -> Bool 
prop_gelems_eq_gelemsU a = gelemsD a == gelemsU a 

prop_gcheckEnumType_eq_gcheckEnumTypeU :: Data a => a -> String -> Bool
prop_gcheckEnumType_eq_gcheckEnumTypeU a s = gcheckEnumTypeD a s == gcheckEnumTypeU a s  

--    check counts 
prop_gcount_eq_gcountU :: Data a => a -> Bool
--    must provide a defined value for gcount - default will do  
prop_gcount_eq_gcountU  a = gcountShowD  ( gdefaultU a ) == gcountShowU  a 

prop_gheader_length_eq_gcountU :: ( Show a, Data a ) => a -> Bool
--    length of header must be same as count 
prop_gheader_length_eq_gcountU  a = ( length.words.gheaderShowD ) ( gdefaultU a ) == gcountShowU  a 

--    this tests if gshow is actually an inverse of gread for any type 
--    this fails is using Maybe or [] monads?? 
prop_inverse_gread ::  ( Data a, Eq a ) => a -> Bool 
prop_inverse_gread a = ( fst.head.gread.gshow ) a == id a 

prop_gheaderShowQ_eq_gheaderShowD :: ( Show a, Data a ) => a -> Bool
--    length of header must be same as count 
prop_gheaderShowQ_eq_gheaderShowD a = gheaderShowQ a == gheaderShowD a 

---------------------------------------

prop_gcheckD_eq_gcheckU :: ( Show a, Data a ) => a -> [String] -> Bool
--    assumes a is undefined 
prop_gcheckD_eq_gcheckU a xs = gcheckD ( gdefaultU a ) xs == gcheckU a xs 

--    checks that type names are the same ( cannot equate functions ) 
prop_gcheck1D_eq_gcheck1U :: ( Show a, Data a ) => a -> Bool
--    assumes a is undefined 
prop_gcheck1D_eq_gcheck1U a = map fst ( gcheck1D ( gdefaultU a ) ) == map fst ( gcheck1U a ) 

--------------------------------------- 
--    UNUSED properties 
---------------------------------------
--    test that the CHECK BP type NamedA lists are identical 
--    again compares NamedA list, so too complex. 
prop_gckD_eq_gckU :: Data a => a -> Bool 
prop_gckD_eq_gckU a = and ( map tupleEq ( zip ( gckD ( gdefaultU a ) ) ( gckU a ) ) )  
--    putStrLn $ "prop_gckD_eq_gckU ( undefined::DBCommonFile ) = " ++ show ( prop_gckD_eq_gckU ( undefined::DBCommonFile )  )     
--    putStrLn $ "prop_gckD_eq_gckU gdefaultD ( undefined::DBCommonFile ) = " ++ show ( prop_gckD_eq_gckU ( gdefaultD ( undefined::DBCommonFile ) ) ) 

--    test that the DEFAULT BP type NamedA lists are identical 
--    the NamedA is fairly complex, so not really worth doing this. 
prop_gdD_eq_gdU :: Data a => a -> Bool 
prop_gdD_eq_gdU a = and ( map tupleEq ( zip ( gdD ( gdefaultU a ) ) ( gdU a ) ) ) 
--    putStrLn $ "show gdD ( gdefaultU a ) = " ++ show ( gdD ( gdefaultU ( undefined::DBCommonFile ) ) )    
--    putStrLn $ "show gdU a = " ++ show ( gdU ( undefined::DBCommonFile ) ) 

--    checks that defaults are the same  
--    does not really make sense, as gdefaultU is needed for both sides. 
prop_gdefaultU_eq_gdefaultQ :: ( Show a, Data a, Eq a ) => a -> Bool 
--    assumes a is undefined 
prop_gdefaultU_eq_gdefaultQ a 
    = undefined 
--    = gdefaultU a == gdefaultQ ( gdefaultU a )  

--    this will only work if the gdQ has manually added test for each Enum type 
--    checks that defaults are the same  
--    show gdQ = "(  DBCommonFile ( TSV ) ( SYS ) ( \" \" ) ( False ) ( 0 ) ( 0 ) ( 0.0 )  )"
--    show gdS = "(  DBCommonFile ( TSV ) ( SYS ) ( \" \" ) ( False ) ( 0 ) ( 0 ) ( 0.0 )  )"
prop_gdU_eq_gdQ :: ( Show a, Data a ) => a -> Bool 
--    assumes a is undefined 
prop_gdU_eq_gdQ a = gdS a == ( gdQ.gdefaultU ) a  

prop_gcheckQ_eq_gcheckD :: ( Show a, Data a ) => a -> [String] -> Bool
--    verifies checks  
prop_gcheckQ_eq_gcheckD a xs = gcheckQ a xs == gcheckD a xs 

prop_gcheckQ_eq_gcheckU :: ( Show a, Data a ) => a -> [String] -> Bool
--    assumes a is undefined 
prop_gcheckQ_eq_gcheckU a xs = gcheckQ ( gdefaultU a ) xs == gcheckU a xs 

--    checks that type names are the same ( cannot equate functions ) 
prop_gcheck1D_eq_gcheck2 :: ( Show a, Data a ) => a -> Bool
--    assumes a is defined 
prop_gcheck1D_eq_gcheck2 a = map fst ( gcheck1D a ) == map fst ( gcheck2 a ) 

--    checks that type names are the same ( cannot equate functions ) 
prop_gcheck2_eq_gcheck1U :: ( Show a, Data a ) => a -> Bool
--    assumes a is undefined 
prop_gcheck2_eq_gcheck1U a = map fst ( gcheck2 ( gdefaultU a ) ) == map fst ( gcheck1U a )   

